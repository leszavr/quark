import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { VaultService } from '../vault/vault.service';
import { JwtSecretRotatedEvent } from '../vault/events/jwt-secret-rotated.event';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class DynamicJwtService {
  private readonly logger = new Logger(DynamicJwtService.name);

  constructor(
    private readonly vaultService: VaultService
  ) {}

  /**
   * –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç JWT —Ç–æ–∫–µ–Ω —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º —Å–µ–∫—Ä–µ—Ç–æ–º –∏–∑ Vault
   */
  async sign(payload: object, options?: { expiresIn?: string }): Promise<string> {
    try {
      const secret = await this.vaultService.getJWTSecret();
      
      return jwt.sign(payload, secret, {
        expiresIn: options?.expiresIn || '1h',
        algorithm: 'HS256',
        issuer: 'quark-auth-service',
      });
    } catch (error) {
      this.logger.error('‚ùå Error signing JWT:', error.message);
      throw error;
    }
  }

  /**
   * –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç JWT —Ç–æ–∫–µ–Ω —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º —Å–µ–∫—Ä–µ—Ç–æ–º –∏–∑ Vault
   * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç graceful –ø–µ—Ä–µ—Ö–æ–¥ –ø—Ä–∏ —Ä–æ—Ç–∞—Ü–∏–∏ —Å–µ–∫—Ä–µ—Ç–æ–≤
   */
  async verify(token: string): Promise<any> {
    try {
      const currentSecret = await this.vaultService.getJWTSecret();
      
      // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è —Å —Ç–µ–∫—É—â–∏–º —Å–µ–∫—Ä–µ—Ç–æ–º
      try {
        return jwt.verify(token, currentSecret, {
          algorithms: ['HS256'],
          issuer: 'quark-auth-service',
        });
      } catch (currentSecretError) {
        this.logger.warn('‚ö†Ô∏è Token verification failed with current secret, trying previous secret...');
        
        // –ï—Å–ª–∏ –Ω–µ –ø—Ä–æ—à–ª–æ, –ø—ã—Ç–∞–µ–º—Å—è —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º —Å–µ–∫—Ä–µ—Ç–æ–º (–¥–ª—è graceful transition)
        const previousSecret = await this.vaultService.getPreviousJWTSecret();
        if (previousSecret) {
          try {
            const payload = jwt.verify(token, previousSecret, {
              algorithms: ['HS256'],
              issuer: 'quark-auth-service',
            });
            
            this.logger.warn('‚úÖ Token verified with previous secret - consider refreshing token');
            return payload;
          } catch (previousSecretError) {
            this.logger.error('‚ùå Token verification failed with both current and previous secrets');
            throw currentSecretError; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –æ—à–∏–±–∫—É
          }
        } else {
          throw currentSecretError;
        }
      }
    } catch (error) {
      this.logger.error('‚ùå Error verifying JWT:', error.message);
      throw error;
    }
  }

  /**
   * –î–µ–∫–æ–¥–∏—Ä—É–µ—Ç JWT —Ç–æ–∫–µ–Ω –±–µ–∑ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è payload)
   */
  decode(token: string): any {
    return jwt.decode(token);
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏—è —Ä–æ—Ç–∞—Ü–∏–∏ JWT —Å–µ–∫—Ä–µ—Ç–∞
   */
  @OnEvent('jwt.secret.rotated')
  handleJwtSecretRotated(event: JwtSecretRotatedEvent) {
    this.logger.log('üîÑ JWT secret rotation detected');
    this.logger.log(`‚è∞ Rotated at: ${event.rotatedAt.toISOString()}`);
    this.logger.log('‚úÖ DynamicJwtService ready for new secret');
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∑–¥–µ—Å—å
    // –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è –∫—ç—à–∞ –∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥—Ä—É–≥–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
  }
}
