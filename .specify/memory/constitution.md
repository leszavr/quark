# Конституция платформы Quark
## Архитектурные принципы и правила разработки

**Версия**: 1.0.0  
**Дата создания**: 3 ноября 2025  
**Статус**: Действующая  
**Источник**: Консолидация ADR-001 по ADR-008

---

## Преамбула

Данная Конституция определяет фундаментальные архитектурные принципы платформы Quark, построенной по концепции **Модульной Космической Станции (МКС)**. Все решения по разработке, интеграции и эволюции системы должны соответствовать этим принципам.

Конституция применяется к:
- Всем новым микросервисам и модулям
- Существующим сервисам при их рефакторинге
- Архитектурным решениям и техническим спецификациям
- Процессам code review и технических обсуждений

---

## Article I: Event-Driven Architecture (Событийная архитектура)

**Источник**: ADR-002

### Принцип
Все межсервисное взаимодействие ДОЛЖНО происходить через асинхронные события.

### Требования

#### 1.1 Обязательное использование NATS JetStream
```text
Каждый сервис ОБЯЗАН:
- Публиковать события в NATS при изменении состояния
- Подписываться на события от других сервисов
- НЕ делать прямых HTTP-вызовов к другим сервисам для бизнес-логики
```

**Источник шины сообщений**: ADR-001 (NATS JetStream выбран вместо Kafka)

#### 1.2 Запрещённые паттерны
```text
❌ ЗАПРЕЩЕНО: blog-service → HTTP → user-service (прямой вызов)
✅ РАЗРЕШЕНО: blog-service → NATS event → user-service subscribes
```

#### 1.3 Исключения
Синхронные вызовы через **gRPC разрешены** только для:
- Критически важных операций, требующих немедленного ответа
- Внутренних технических вызовов (не бизнес-логика)
- Примеры: health checks, service discovery queries

**См. Article IV** для правил использования gRPC.

#### 1.4 Надёжность доставки событий
```text
Обязательно:
- Durable consumers для каждого подписчика
- Dead Letter Queue (DLQ) с max_deliver=5
- Exponential backoff для повторных попыток
- Acknowledgment (ack) после успешной обработки
```

### Обоснование
- Полная независимость сервисов
- Гибкость и расширяемость системы
- Поддержка human-in-the-loop и AI Ops Agent

### Последствия
- Сложность диагностики → решается через OpenTelemetry tracing
- Eventual consistency вместо strong consistency
- Необходимость идемпотентной обработки событий

---

## Article II: Universal Docking Interface (Универсальный стыковочный интерфейс)

**Источник**: ADR-003, ADR-008

### Принцип
Каждый модуль ОБЯЗАН предоставлять стандартизированный интерфейс для интеграции с Plugin Hub.

### Требования

#### 2.1 Module Manifest
```yaml
# Каждый сервис ОБЯЗАН иметь module-manifest.yaml
id: <service-name>
name: "<Human-readable Name>"
version: "1.0.0"
technology: "Node.js | Python | Go | .NET"
framework: "Express | NestJS | FastAPI | Gin"

# Обязательные поля
capabilities: [...]
security:
  requiresAuth: true
  permissions: [...]
endpoints:
  health: /health        # ОБЯЗАТЕЛЬНО
  status: /status        # ОБЯЗАТЕЛЬНО
  manifest: /manifest    # ОБЯЗАТЕЛЬНО
```

#### 2.2 Стандартные HTTP endpoints
```text
GET  /health          - Health check (200 OK = alive)
GET  /status          - Детальный статус модуля
GET  /manifest        - Возвращает ModuleManifest
POST /shutdown        - Graceful shutdown (опционально)
```

#### 2.3 Автоматическая регистрация в Plugin Hub
```text
При старте модуль ОБЯЗАН:
1. Отправить POST /modules/register в Plugin Hub
2. Получить конфигурацию от Hub
3. Начать отправку heartbeat каждые N секунд
4. Уведомить Hub при shutdown
```

#### 2.4 Health Check формат
```typescript
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;     // ISO 8601
  uptime: number;        // Секунды
  checks: {
    database?: 'pass' | 'fail';
    nats?: 'pass' | 'fail';
    vault?: 'pass' | 'fail';
  };
}
```

### Обоснование
- Параллельная разработка независимых модулей
- Поддержка сторонних разработчиков
- Возможность замены модулей без изменения системы
- Автоматическое обнаружение и мониторинг

### Последствия
- Необходимость строгих контрактов между модулями
- Централизованное управление через Plugin Hub
- Стандартизация независимо от tech stack

### Связь с другими статьями
- **Article VIII**: Plugin Hub как единственный Command Module

---

## Article III: JWT Authentication (Единая аутентификация)

**Источник**: ADR-005

### Принцип
Все сервисы ДОЛЖНЫ использовать единый формат аутентификации через JWT токены с централизованным управлением секретами.

### Требования

#### 3.1 JWT структура
```json
{
  "sub": "<user-id>",
  "roles": ["user", "vip", "moderator", "admin"],
  "permissions": ["blog.read", "blog.write", "blog.publish"],
  "type": "user | service | hub",
  "exp": 1234567890,
  "iat": 1234567890
}
```

#### 3.2 Трёхуровневая система токенов
```text
1. User tokens     - TTL: 24 часа
2. Service tokens  - TTL: 24 часа
3. Hub tokens      - TTL: 48 часов
```

#### 3.3 Централизованное управление секретами
```text
ОБЯЗАТЕЛЬНО использовать HashiCorp Vault для:
- Хранения JWT секретов
- Автоматической ротации (каждые 30 минут)
- Graceful transition между старым и новым секретом
```

#### 3.4 Валидация токенов
```text
Запрещено:
❌ Прямые вызовы к auth-service для валидации

Разрешено:
✅ blog-service → Plugin Hub → auth-service/validate
   (через Enterprise JWT Middleware)
```

### Обоснование
- Простота и масштабируемость
- Поддержка RBAC (Role-Based Access Control)
- Совместимость с BFF и API Gateway
- Enterprise-grade безопасность

### Последствия
- Все сервисы должны интегрироваться с Vault
- Необходимость event-driven уведомлений о ротации секретов
- Обязательная поддержка graceful secret transition

---

## Article IV: gRPC для внутренних синхронных вызовов

**Источник**: ADR-006

### Принцип
Для синхронных внутренних вызовов между сервисами СЛЕДУЕТ использовать gRPC. REST остаётся для внешнего публичного API.

### Требования

#### 4.1 Применимость gRPC
```text
Использовать gRPC для:
- Синхронных операций, требующих немедленного ответа
- Внутренних технических вызовов между сервисами
- AI-генерации с server streaming
- Высоконагруженных операций

Примеры:
✅ ai-orchestrator → ai-writer (генерация текста)
✅ blog-service → media-service (проверка статуса загрузки)
✅ auth-service → user-service (валидация профиля)
```

#### 4.2 REST для внешнего API
```text
REST/HTTP остаётся для:
- Публичного API для frontend приложений
- Внешних интеграций (webhooks, OAuth)
- Административных панелей
```

#### 4.3 Protocol Buffers контракты
```text
Обязательно:
- Все gRPC сервисы ДОЛЖНЫ иметь .proto файлы
- Централизованное хранение схем в репозитории
- Автоматическая генерация клиентов (protoc + buf)
- Версионирование API в proto файлах
```

#### 4.4 Технические требования
```text
- Встроенные таймауты и retry логика
- Поддержка streaming для AI-генерации
- Строгая типизация через Protobuf
- Документирование через grpc-gateway (OpenAPI мост)
```

### Обоснование
- Высокая производительность (бинарный формат)
- Строгая типизация (ошибки на этапе компиляции)
- Поддержка потоков (streaming)
- Автоматическая генерация SDK на разных языках

### Последствия
- Требуется централизованное управление .proto файлами
- Сложнее отлаживать (нужен grpcurl или BloomRPC)
- Необходимость документирования gRPC endpoint'ов

---

## Article V: WebAssembly для безопасных пользовательских модулей

**Источник**: ADR-007

### Принцип
Для небольших изолированных модулей от сторонних разработчиков СЛЕДУЕТ использовать WebAssembly как более безопасную альтернативу Docker.

### Требования

#### 5.1 Применимость WASM
```text
Использовать WASM для:
- Лёгких пользовательских плагинов (< 10MB)
- Изолированных задач без доступа к системе
- AI-агентов с ограниченными возможностями
- Фильтров и трансформеров контента

Примеры:
✅ seo-analyzer - анализ текста
✅ ai-summarizer-light - краткая генерация
✅ custom-filter - пользовательский фильтр ленты
```

#### 5.2 Ограничения WASM
```text
НЕ использовать WASM для:
❌ Тяжёлых задач (обработка видео, полноценные LLM)
❌ Модулей, требующих доступ к файловой системе
❌ Модулей с внешними зависимостями
```

#### 5.3 Module Manifest для WASM
```yaml
type: wasm  # вместо docker
runtime: wasmedge | wasmer
permissions:
  - http:outbound       # ограниченный HTTP-клиент
  - events:publish      # только публикация событий
  # НЕТ доступа к файловой системе, сети, БД
```

#### 5.4 Безопасность
```text
Обязательно:
- Выполнение только в изолированной песочнице
- Запрет доступа к host system
- Лимиты по памяти и CPU
- Таймауты выполнения
```

### Обоснование
- Высокая безопасность через изоляцию
- Быстрый запуск (микросекунды)
- Кроссплатформенность
- Малый размер бинарников

### Последствия
- Требуется новый module-runner для WASM
- Ограниченные возможности по сравнению с Docker
- Необходимость обучения разработчиков Rust/Go/AssemblyScript

---

## Article VI: AI Operations Agent (ИИ для DevOps)

**Источник**: ADR-004

### Принцип
ИИ должен не только генерировать контент для пользователей, но и обслуживать саму систему.

### Требования

#### 6.1 AI Ops Agent функциональность
```text
ai-ops-agent ДОЛЖЕН:
- Анализировать метрики системы (CPU, память, latency)
- Обнаруживать аномалии в логах
- Предлагать оптимизации конфигурации
- Генерировать отчёты о состоянии системы
- Создавать предложения по масштабированию
```

#### 6.2 Human-in-the-Loop
```text
ОБЯЗАТЕЛЬНО:
- Все критические решения требуют подтверждения человека
- Автоматические действия только для некритичных операций
- Аудит всех действий AI Ops Agent
- Возможность отката автоматических изменений
```

#### 6.3 Интеграция с мониторингом
```text
ai-ops-agent получает данные из:
- Prometheus/Grafana (метрики)
- ELK Stack (логи)
- NATS events (системные события)
- OpenTelemetry (трейсы)
```

### Обоснование
- Снижение нагрузки на DevOps команду
- Самооптимизация системы
- Проактивное обнаружение проблем
- Обратная связь для обучения ИИ

### Последствия
- Требуется тщательная настройка порогов
- Необходимость мониторинга самого AI Agent
- Риск ложных срабатываний

---

## Article VII: Simplicity Gate (Врата простоты)

**Адаптация из Spec-Kit Article VII**

### Принцип
Каждый новый сервис должен стремиться к минимальной сложности.

### Требования

#### 7.1 Максимальное количество компонентов
```text
Для начальной реализации сервиса:
- Максимум 3 основных компонента
- Дополнительные компоненты требуют обоснования

Примеры правильной архитектуры:
✅ user-service: NestJS + TypeORM + PostgreSQL (3 компонента)
✅ media-service: Node.js + Sharp + MinIO (3 компонента)

Примеры избыточной архитектуры:
❌ user-service: NestJS + TypeORM + PostgreSQL + Redis + 
   Elasticsearch + RabbitMQ (6 компонентов) - требует обоснования
```

#### 7.2 Запрет future-proofing
```text
ЗАПРЕЩЕНО:
- Добавлять функциональность "на будущее"
- Создавать абстракции "на всякий случай"
- Усложнять архитектуру "для масштабирования"

ПРИНЦИП: 
Решаем сегодняшние проблемы, не завтрашние.
```

#### 7.3 Complexity Tracking
```text
В plan.md ОБЯЗАТЕЛЬНА секция:
## Complexity Tracking
- Components: 3/3 (в пределах лимита)
- External dependencies: 2 (NATS, PostgreSQL)
- Justification: [если > 3 компонентов]
```

### Обоснование
- Уменьшение технического долга
- Быстрая разработка и деплой
- Простота поддержки и отладки

### Последствия
- Необходимость явного обоснования сложных решений
- Фокус на MVP подходе

---

## Article VIII: Plugin Hub как единственный Command Module

**Адаптация из ADR-008, Spec-Kit Article II**

### Принцип
Plugin Hub является единственным центральным узлом управления. Все межсервисное взаимодействие идёт через него.

### Требования

#### 8.1 Запрет прямых вызовов
```text
ЗАПРЕЩЕНО:
❌ blog-service → прямой HTTP → auth-service
❌ user-service → прямой HTTP → media-service

РАЗРЕШЕНО:
✅ blog-service → Plugin Hub → auth-service/validate
✅ user-service → Plugin Hub → media-service
```

#### 8.2 Enterprise JWT Middleware
```text
Plugin Hub предоставляет:
- Централизованную валидацию JWT
- mTLS для внутренних вызовов
- Circuit breaker для отказоустойчивости
- Rate limiting для защиты
- Кэширование результатов валидации
```

#### 8.3 Service Discovery
```text
Модули ДОЛЖНЫ использовать Plugin Hub для:
- Обнаружения других модулей
- Получения endpoint'ов других сервисов
- Проверки availability других модулей
```

### Обоснование
- Централизованное управление всей системой
- Enterprise-grade безопасность
- Единая точка мониторинга и логирования
- Возможность A/B тестирования на уровне Hub

### Последствия
- Plugin Hub становится single point of failure
- Необходимость высокой доступности Plugin Hub
- Все изменения API проходят через Hub

---

## Article IX: Test-First Development (Разработка через тесты)

**Адаптация из Spec-Kit Article III**

### Принцип
Для всех новых сервисов реализация кода ДОЛЖНА следовать после написания тестов.

### Требования

#### 9.1 Последовательность разработки
```text
ОБЯЗАТЕЛЬНАЯ последовательность:
1. Написать spec.md (спецификация требований)
2. Создать contracts/ (OpenAPI, AsyncAPI, .proto)
3. Написать contract tests (тесты контрактов)
4. Убедиться, что тесты FAIL (Red phase)
5. ТОЛЬКО ЗАТЕМ писать реализацию
6. Добиться прохождения тестов (Green phase)
7. Рефакторинг (Refactor phase)
```

#### 9.2 Типы тестов
```text
Приоритет тестирования:
1. Contract tests - проверка соблюдения контрактов
2. Integration tests - взаимодействие с внешними системами
3. E2E tests - сквозные сценарии
4. Unit tests - изолированная бизнес-логика
```

#### 9.3 Integration-First Testing
```text
Приоритет реальным окружениям:
✅ Реальная PostgreSQL БД (в Docker)
✅ Реальный NATS сервер
✅ Реальный Vault

❌ НЕ использовать mocks для:
- Баз данных
- Брокеров сообщений
- Критичных сервисов
```

### Обоснование
- Код генерируется под тесты, а не наоборот
- Выявление проблем на ранней стадии
- Документация через тесты
- Уверенность в корректности реализации

### Последствия
- Увеличение времени на начальную разработку
- Необходимость Docker окружения для тестов
- Высокая скорость при рефакторинге

---

## Enforcement (Применение конституции)

### В процессе разработки

#### Обязательные проверки при создании нового сервиса:

```markdown
### Phase -1: Pre-Implementation Gates

#### Simplicity Gate (Article VII)
- [ ] Используется ≤3 компонентов?
- [ ] Нет future-proofing?
- [ ] Сложность обоснована?

#### Universal Docking Gate (Article II)
- [ ] module-manifest.yaml создан?
- [ ] Стандартные endpoints реализованы?
- [ ] Автоматическая регистрация в Plugin Hub?

#### Authentication Gate (Article III)
- [ ] JWT интеграция через Vault?
- [ ] Использование Enterprise JWT Middleware?
- [ ] НЕТ прямых вызовов к auth-service?

#### Event-Driven Gate (Article I)
- [ ] Асинхронные события через NATS?
- [ ] НЕТ прямых HTTP вызовов между сервисами?
- [ ] Durable consumers настроены?

#### Test-First Gate (Article IX)
- [ ] Contract tests написаны ДО реализации?
- [ ] Тесты провалились (Red phase)?
- [ ] Integration tests используют реальные сервисы?
```

### В Code Review

Все Pull Request'ы ДОЛЖНЫ проходить проверку на соответствие Конституции:

```text
[ ] Article I: События через NATS?
[ ] Article II: UDI реализован?
[ ] Article III: JWT через Vault?
[ ] Article VII: Сложность обоснована?
[ ] Article VIII: Через Plugin Hub?
[ ] Article IX: Тесты написаны первыми?
```

### Исключения

Отступление от Конституции разрешено только при:
1. Явном обосновании в ADR
2. Утверждении Chief Architect
3. Документировании в `docs/exceptions/`

---

## Связанные документы

- `docs/adr/` - Архитектурные решения
- `docs/architecture/universal-docking-interface.md` - Детальная спецификация UDI
- `docs/architecture/containers.md` - Обзор микросервисной архитектуры
- `.specify/templates/plan-template.md` - Шаблон технического плана
- `.specify/templates/spec-template.md` - Шаблон спецификации требований

---

## Обновления Конституции

**Версия 1.0.0** (3 ноября 2025):
- Начальная версия
- Консолидация ADR-001 по ADR-008
- Адаптация принципов Spec-Kit (Articles VII, IX)
- Добавление enforcement механизмов

**Процесс изменения**:
1. Предложение изменения как ADR-XXX
2. Обсуждение в команде
3. Утверждение Chief Architect
4. Обновление версии Конституции
5. Уведомление всей команды

---

**Подготовлено**: AI Assistant + Chief Architect  
**Статус**: Действующая конституция платформы Quark  
**Применимость**: Все новые разработки с 3 ноября 2025
