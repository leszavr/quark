## 🚀 **План разработки MVP Quark**
**Цель MVP**:  
Запустить минимальную, но полностью рабочую версию платформы, где пользователь может:
- Зарегистрироваться и войти.
- Создать блог.
- Опубликовать пост (с медиа).
- Отправить сообщение в мессенджере.
- Увидеть базовую интеграцию ИИ (генерация поста).
- Запустить систему локально и в staging.

**Срок**: 2 недели (как указано в `roadmap.md`)

---

## 🔑 **Ключевые принципы**
1. **ИИ-нативная разработка**: ИИ (Qwen) участвует в проектировании и генерации кода, но **человек одобряет**.
2. **Модульность с первого дня**: Каждый сервис — автономный модуль с `module-manifest.yaml`.
3. **Event-driven архитектура**: Все сервисы общаются через **NATS JetStream**.
4. **Безопасность по умолчанию**: JWT, rate limiting, CORS, аудит.
5. **Документация как часть CI/CD**: Все изменения требуют обновления документации.

---

# 🧱 **Фаза 1: Подготовка и окружение (День 1–2)**

### ✅ Цель:
Подготовить базовую инфраструктуру, CI/CD и шаблоны для быстрой разработки.

| Задача | Действия | Ответственный |
|-------|--------|--------------|
| 1.1. Инициализировать репозиторий | - Создать `quark-platform` в GitHub/GitLab<br>- Настроить `docs/`, `services/`, `.github/workflows/` | DevOps |
| 1.2. Настроить CI/CD | - Добавить GitHub Actions для:<br>  • Запуска `onboarding.md`<br>  • Проверки покрытия документации (`docs-coverage.sh`)<br>  • Автогенерации OpenAPI, AsyncAPI, Mermaid | DevOps + Qwen |
| 1.3. Создать шаблоны сервисов | - Готовые шаблоны для:<br>  • NestJS (`blog-service`, `messaging-service`)<br>  • FastAPI (`auth-service`, `ai-orchestrator`)<br>  • `module-manifest.yaml`, `Dockerfile`, `health_check` | Архитектор + Qwen-Coder |
| 1.4. Запустить локальное окружение | - `docker-compose.yml` с:<br>  • API Gateway<br>  • NATS<br>  • PostgreSQL<br>  • MinIO (для медиа)<br>  • Grafana + Prometheus (минимум) | DevOps |

###  📂 **Добавить `module-manifest.yaml` в каждый сервис**

> "Модульность с первого дня"


```yaml
# services/auth-service/module-manifest.yaml
name: auth-service
version: 1.0.0
type: docker
requires:
  - database: postgres
  - event_bus: nats
exposes:
  - api: /auth/*
  - events: user.created
health_check: /health
```


###  📄 **Пример `docker-compose.dev.yml`**


```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  api-gateway:
    image: traefik:v2.9
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
    ports:
      - "80:80"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  auth-service:
    build: ./services/auth-service
    ports:
      - "3001:3001"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/auth
    depends_on:
      - postgres

  blog-service:
    build: ./services/blog-service
    ports:
      - "3004:3004"
    depends_on:
      - postgres

  media-service:
    build: ./services/media-service
    ports:
      - "3003:3003"
    depends_on:
      - minio

  messaging-service:
    build: ./services/messaging-service
    ports:
      - "3005:3005"

  ai-orchestrator:
    build: ./services/ai-orchestrator
    ports:
      - "3006:3006"

  nats:
    image: nats:2.9-alpine
    command: nats-server --jetstream
    ports:
      - "4222:4222"
      - "8222:8222"

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: quark
      POSTGRES_USER: quark
      POSTGRES_PASSWORD: quark
    volumes:
      - postgres_data:/var/lib/postgresql/data

  minio:
    image: minio/minio:latest
    environment:
      MINIO_ROOT_USER: admin
      MINIO_ROOT_PASSWORD: password
    command: server /data
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: quark
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  minio_data:
  grafana_data:
```

###  📁 **Пример скрипта `scripts/onboarding.sh` **

```bash
# scripts/onboarding.sh
#!/bin/bash
echo "🚀 Запуск Quark MVP..."

# Проверка зависимостей
command -v docker-compose >/dev/null 2>&1 || { echo "Docker Compose не установлен"; exit 1; }

# Запуск
docker-compose -f docker-compose.dev.yml up --build -d

echo "✅ Система запущена:"
echo "   - Auth: http://localhost:3001/health"
echo "   - Blog: http://localhost:3004/api/v1/posts"
echo "   - Grafana: http://localhost:3000"

# Проверка готовности
sleep 10
curl -f http://localhost:3001/health || echo "⚠️ auth-service не запущен"
```

> 📌 **Результат**: Любой разработчик может выполнить `./scripts/onboarding.sh` и запустить систему за 5 минут.

---

# ⚙️ **Фаза 2: Разработка критичных сервисов (День 3–8)**

## 🔹 **2.1. `auth-service` (День 3–4)**
**Цель**: Аутентификация и авторизация через JWT.

### Задачи:
- Реализовать `/auth/register`, `/auth/login`, `/auth/refresh`.
- Генерация JWT с `sub`, `roles`, `permissions` (ADR-005).
- Хранение паролей — bcrypt.
- Rate limiting: 100 запросов/час на IP.
- CORS: только `quark.com`, `localhost:3000`.
- Интеграция с `user-service` через gRPC.

### Технологии:
- FastAPI (Python)
- PostgreSQL (таблица `users`)
- gRPC → `user-service`

### Документация:
- `openapi.yaml`
- `module-manifest.yaml`
- Диаграмма в `c4-containers.md`

---

## 🔹 **2.2. `user-service` (День 4–5)**
**Цель**: Управление профилями пользователей.

### Задачи:
- CRUD: `/user/{id}`, `/user/{username}`.
- Валидация: только владелец может редактировать.
- Интеграция с `auth-service` (gRPC).
- Хранение аватаров → MinIO.
- Health check: `/health`.

### Технологии:
- NestJS (TypeScript)
- PostgreSQL (таблица `profiles`)
- MinIO (через S3 API)

---

## 🔹 **2.3. `blog-service` (День 5–7)**
**Цель**: Публикация и чтение постов.

### Задачи:
- `/posts` — GET, POST, PUT, DELETE.
- Поддержка медиа: загрузка → `media-service`.
- Санитизация HTML (XSS-защита).
- Права: только автор может редактировать.
- Генерация события: `post.published` → NATS.

### Технологии:
- NestJS
- PostgreSQL (`posts`, `tags`)
- NATS JetStream (публикация событий)

### Метрики (SLO):
- Latency (p95): < 500 мс (чтение), < 1.5 с (запись)
- Error Rate: < 0.1%

---

## 🔹 **2.4. `media-service` (День 7–8)**
**Цель**: Загрузка, хранение и обработка медиа.

### Задачи:
- `/upload` — приём файлов.
- Конвертация: WebP, resize (через PIL).
- Хранение: MinIO.
- Генерация превью.
- Событие: `media.uploaded`.

### Технологии:
- FastAPI
- MinIO
- NATS
- PIL / ImageMagick

> ⚠️ **Важно**: Избегать блокировки event loop — использовать `async def resize_image_async()` (см. `workflow-example.md`).

---

# 🌐 **Фаза 3: Интеграция и API (День 9–10)**

## 🔹 **3.1. `api-gateway` (День 9)**
**Цель**: Единая точка входа, маршрутизация, безопасность.

### Задачи:
- Маршрутизация: `/api/v1/auth/*` → `auth-service` и т.д.
- Аутентификация: проверка JWT.
- Rate limiting: 1000 req/hour на IP.
- CORS, WAF (Cloudflare).
- Health check: `/health`.

### Технологии:
- Express Gateway / Kong / Traefik
- JWT middleware

---

## 🔹 **3.2. `bff` (Backend for Frontend) (День 10)**
**Цель**: Агрегация данных для фронтенда.

### Задачи:
- `/me` → объединяет данные из `user-service`, `blog-service`.
- `/feed` → посты + медиа + метрики.
- Обработка ошибок, кэширование.

### Технологии:
- NestJS
- Redis (кэш)

---

## 🔹 **3.3. Настройка NATS JetStream (весь период)**
**Цель**: Обеспечить надёжную доставку событий.

### Задачи:
- Создать `streams`: `posts`, `media`, `auth`.
- Durable consumers для `ai-orchestrator`, `notification-service`.
- Replay событий при старте сервиса.

> ✅ Подтверждено в `adr-001-nats-vs-kafka.md`: NATS — лучший выбор для MVP.

---

# 💬 **Фаза 4: Мессенджер и ИИ (День 11–12)**

## 🔹 **4.1. `messaging-service` (День 11)**
**Цель**: WebSocket-чат между пользователями.

### Задачи:
- WebSocket-соединение с JWT в URL.
- Шифрование: WSS.
- Rate limiting: 100 сообщений/минуту.
- Событие: `message.sent`.

### Технологии:
- NestJS + WebSocket Gateway
- NATS (рассылка)
- Redis (хранение сессий)

---

## 🔹 **4.2. `ai-orchestrator` (День 12)**
**Цель**: Запуск ИИ-агентов по событиям.

### Задачи:
- Подписка на `post.published`.
- Вызов LLM (Ollama + `phi-3-mini`).
- Генерация рекомендаций: "Вам понравится этот пост".
- Событие: `ai.suggestion.generated`.

### Технологии:
- FastAPI
- LangChain
- Ollama (локальный LLM)
- NATS

> ✅ Подтверждено в `tech-matrix.md`: Ollama + LangChain — лучший выбор.

---

# 🧪 **Фаза 5: Тестирование и деплой (День 13–14)**

## 🔹 **5.1. Написание тестов**
| Уровень | Задачи | Инструменты |
|--------|-------|------------|
| Unit | Логика функций, валидация | Jest, Pytest |
| Integration | API, gRPC, NATS | Supertest, HTTPX |
| E2E | Регистрация → пост → сообщение | Playwright |
| Load | 100 RPS, latency < 500 мс | k6 |

## 🧪 Структура тестов
```
services/
├── auth-service/
│   ├── tests/
│   │   ├── unit/
│   │   └── integration/
├── blog-service/
│   ├── tests/
│   │   ├── unit/
│   │   └── integration/
```

> ✅ Все тесты запускаются через `pytest` / `npm test`

> 📌 Цель: 95% покрытие, 0 критических багов.

---

## 🔹 **5.2. Деплой в staging**
| Действие | Описание |
|--------|--------|
| Собрать образы | `docker build` для всех сервисов |
| Запустить в K8s | Helm chart или `kubectl apply` |
| Проверить health | Все `/health` — 200 OK |
| Запустить load-тест | k6 → проверить SLO |
| Проверить мониторинг | Grafana: latency, errors, rate |

---

## 🔹 **5.3. Документация и post-mortem**
| Действие | Описание |
|--------|--------|
| Обновить `README.md` | Ссылки на сервисы, API |
| Проверить `docs-coverage` | 100% покрытие |
| Запустить `check-docs-coverage.sh` | Блокировка CI при ошибках |
| Написать post-mortem | Если были инциденты — заполнить шаблон |

---

# 🧩 **Что отложить на потом (Post-MVP)**

| Функция | Обоснование |
|--------|-----------|
| **Plugin Hub** | MVP — без модулей, но с поддержкой `module-manifest.yaml` |
| **AI Ops Agent** | Самооптимизация — для v2 |
| **Мобильное приложение** | React Native — после веб-версии |
| **Модерация ИИ** | Пока ручная, автоматизация — позже |
| **WASM-модули** | Поддержка в архитектуре есть, но реализация — на этапе модульности |
| **Резервное копирование** | Пока ручное, `recovery-checklist.md` — для v1.1 |

---

# 📅 **Итоговый график (2 недели)**

| День | Задачи |
|-----|-------|
| 1–2 | Подготовка: CI/CD, шаблоны, docker-compose |
| 3–4 | `auth-service` |
| 5 | `user-service` |
| 6–7 | `blog-service` |
| 8 | `media-service` |
| 9 | `api-gateway` |
| 10 | `bff` + NATS |
| 11 | `messaging-service` |
| 12 | `ai-orchestrator` |
| 13 | Тестирование (unit, integration, E2E) |
| 14 | Load-тест, staging, документация, post-mortem |

---

# 🎯 **Критерии успеха MVP**
- [x] Все сервисы запускаются локально и в staging.
- [x] Пользователь может зарегистрироваться, создать пост, отправить сообщение.
- [x] ИИ генерирует хотя бы одну рекомендацию.
- [x] Документация 100% актуальна.
- [x] SLO соблюдены: latency, availability, error rate.
- [x] CI/CD работает, блокирует при ошибках.

