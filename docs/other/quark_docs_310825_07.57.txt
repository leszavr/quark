root
    ---brd.md---
          "
        # BRD: Quark — платформа для самовыражения с ИИ
        
        ## 1. Цель проекта
        Создать экспериментальную, высокодинамичную, модульную систему Quark, сочетающую:
        - Мультисайтовый сервис блогов (`quark.com/user/username`)
        - Интеллектуальный мессенджер с ИИ-агентами
        - Возможность расширения через сторонние модули
        
        Цель — **демонстрация возможности создания системы ИИ от проектирования до деплоя**.
        
        ## 2. Концепция
        - Первая система, **спроектированная и реализованная с участием ИИ**
        - **Человек в цикле**: ИИ предлагает, человек одобряет
        - **Гибрид форматов**: блог + соцсеть в одном профиле
        - **Модульность по принципу МКС**: каждый сервис — стыкуемый модуль
        
        ## 3. Целевая аудитория
        - Блогеры, контент-мейкеры
        - Разработчики, желающие создавать плагины
        - Экспериментаторы, изучающие ИИ-автономные системы
        
        ## 4. KPI (необязательные, для оценки успеха)
        - 1000 активных пользователей за 3 месяца
        - 10 сторонних модулей от сообщества
        - 50% рекомендаций ИИ принимаются без правок
        
        ## 5. Ограничения
        - Не коммерческий продукт (эксперимент)
        - Поддержка законодательства РФ (ФЗ-152, ФЗ-149)
        - Локализация — на этапе завершения MVP
        
        ## 6. Ожидаемые выгоды
        - Доказательство возможности **ИИ-автономного проектирования**
        - Создание **открытой экосистемы модулей**
        - Платформа для исследований в области **AI Ops, AIOps, human-in-the-loop**
          "
    ---capacity-plan.md---
          "
        # Capacity Plan: Планирование производительности
        
        ## 1. Оценка нагрузки
        - Планируем: 10K активных пользователей
        - Пиковая нагрузка: 100 RPS (запросов в секунду)
        - Наиболее нагруженные операции:
          - Чтение постов: 70% трафика
          - Публикация: 20%
          - Мессенджер: 10%
        
        ## 2. Расчёт ресурсов
        | Сервис | CPU | RAM | Диск | Реплики |
        |-------|-----|-----|------|--------|
        | auth-service | 0.5 vCPU | 512 MB | 1 GB | 2 |
        | blog-service | 1 vCPU | 1 GB | 5 GB | 2 |
        | media-service | 2 vCPU | 2 GB | 50 GB (MinIO) | 2 |
        | ai-orchestrator | 2 vCPU | 4 GB | 10 GB | 2 |
        | NATS | 1 vCPU | 1 GB | 10 GB | 1 |
        
        ## 3. Хранение данных
        - Пользователи: 10K × 1 KB = 10 MB
        - Посты: 100K × 5 KB = 500 MB
        - Медиа: 50K изображений × 2 MB = 100 GB
        - Логи: 10 GB/день → 300 GB/мес
        
        ## 4. Масштабирование
        - Горизонтальное: Kubernetes HPA (на основе CPU)
        - Кеширование: Redis для постов и профилей
          "
    ---ci-cd-pipeline.yml---
          "
        name: CI/CD Pipeline
        
        on: [push]
        
        jobs:
          test:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v4
              - run: docker build -t quark/auth-service .
              - run: npm test
        
          deploy:
            if: github.ref == 'refs/heads/main'
            runs-on: ubuntu-latest
            steps:
              - uses: azure/docker-login@v1
              - run: docker push quark/auth-service:latest
              - run: kubectl apply -f k8s/auth-deployment.yaml
          "
    ---compliance-checklist.md---
          "
        # Compliance Checklist (РФ)
        
        ## ФЗ-152 "О персональных данных"
        - [x] Согласие на обработку данных (в интерфейсе)
        - [x] Право на удаление (реализовано в `user-service/delete`)
        - [x] Хранение данных в РФ 
        - [x] Шифрование PII:
          - В транзите: TLS 1.3
          - В покое: AES-256 (PostgreSQL TDE)
        - [x] Регистрация в Роскомнадзоре (если требуется)
        - [x] Назначен ответственный за обработку ПДн
        
        ## ФЗ-149 "Об информации"
        - [x] Регистрация домена
        - [x] Контакты администратора
        - [x] Модерация контента
          "
    ---deployment-runbook.md---
          "
        # Deployment Runbook
        
        ## 1. Подготовка
        - Убедиться, что Kubernetes кластер работает
        - Проверить наличие секретов в Vault
        
        ## 2. Деплой
        ```bash
        kubectl apply -f k8s/blog-deployment.yaml
        kubectl rollout status deployment/blog-service
           ```
        ## 3. Проверка 
        
        - /health → 200 OK
        - Логи: kubectl logs blog-pod-123
        - Метрики: Grafana → latency, RPS
          "
    ---docker-compose.dev.yml---
          "
        # docker-compose.dev.yml
        version: '3.8'
        
        services:
          api-gateway:
            image: traefik:v2.9
            command:
              - "--api.insecure=true"
              - "--providers.docker=true"
            ports:
              - "80:80"
              - "8080:8080"
            volumes:
              - /var/run/docker.sock:/var/run/docker.sock
        
          auth-service:
            build: ./services/auth-service
            ports:
              - "3001:3001"
            environment:
              - DATABASE_URL=postgresql://user:pass@postgres:5432/auth
            depends_on:
              - postgres
        
          blog-service:
            build: ./services/blog-service
            ports:
              - "3004:3004"
            depends_on:
              - postgres
        
          media-service:
            build: ./services/media-service
            ports:
              - "3003:3003"
            depends_on:
              - minio
        
          messaging-service:
            build: ./services/messaging-service
            ports:
              - "3005:3005"
        
          ai-orchestrator:
            build: ./services/ai-orchestrator
            ports:
              - "3006:3006"
        
          nats:
            image: nats:2.9-alpine
            command: nats-server --jetstream
            ports:
              - "4222:4222"
              - "8222:8222"
        
          postgres:
            image: postgres:15
            environment:
              POSTGRES_DB: quark
              POSTGRES_USER: quark
              POSTGRES_PASSWORD: quark
            volumes:
              - postgres_data:/var/lib/postgresql/data
        
          minio:
            image: minio/minio:latest
            environment:
              MINIO_ROOT_USER: admin
              MINIO_ROOT_PASSWORD: password
            command: server /data
            ports:
              - "9000:9000"
              - "9001:9001"
            volumes:
              - minio_data:/data
        
          grafana:
            image: grafana/grafana:latest
            ports:
              - "3000:3000"
            environment:
              GF_SECURITY_ADMIN_PASSWORD: quark
            volumes:
              - grafana_data:/var/lib/grafana
        
        volumes:
          postgres_data:
          minio_data:
          grafana_data:
          "
    ---glossary.md---
          "
        # 📘 Глоссарий терминов
        
        | Термин | Описание |
        |--------|--------|
        | **ADR** | Архитектурное решение с обоснованием |
        | **Event Bus** | NATS — шина событий для асинхронной коммуникации |
        | **Human-in-the-loop** | ИИ предлагает, человек одобряет |
        | **Module Manifest** | `module-manifest.yaml` — метаданные модуля |
        | **Docking Hub** | Сервис, подключающий модули к системе |
        | **AI Ops Agent** | ИИ, анализирующий метрики и предлагающий исправления |
        | **SLO** | Целевой уровень обслуживания (например, 99.9% uptime) |
        | **PII** | Персональные данные (email, IP и др.) |
          "
    ---load-test-scenarios.md---
          "
        # Load Test Scenarios
        
        ## 1. Цель
        Проверить производительность на production-like окружении.
        
        ## 2. Инструмент
        - k6 / Locust
        
        ## 3. Сценарии
        | Сценарий | Пользователи | Длительность | Цель |
        |---------|-------------|-------------|------|
        | Чтение постов | 1000 VU | 10 мин | Проверить latency и ошибки |
        | Публикация постов | 500 VU | 15 мин | Проверить обработку медиа |
        | Отправка сообщений | 300 VU | 10 мин | Проверить WebSocket |
        | Работа ИИ-агента | 100 VU | 5 мин | Проверить время генерации |
          "
    ---monitoring-strategy.md---
          "
        # Monitoring Strategy
        
        ## 1. Инструменты
        - OpenTelemetry — сбор трейсов, метрик, логов
        - Grafana — визуализация
        - Tempo — трейсы
        - Mimir — метрики
        - Loki — логи
        - Sentry — отслеживание ошибок
        
        ## 2. Ключевые метрики (RED)
        - **Rate**: запросов в секунду
        - **Error**: процент ошибок (5xx)
        - **Duration**: время ответа
        
        ## 3. SLO
        - Доступность: 99.9%
        - Latency: 95% запросов < 500 мс
        - Error Budget: 0.1% ошибок в месяц
        
        ## 4. Алертинг
        - При latency > 1s — уведомление в Telegram
        - При 5xx > 1% — алерт в Grafana
        - При отказе сервиса — перезапуск через Kubernetes
          "
    ---onboarding.md---
          "
        # 🚀 Onboarding: Как начать работать с Quark
        
        ## Цель
        Помочь новому разработчику:
        - Запустить Quark локально за 5 минут
        - Понять архитектуру
        - Создать и подключить модуль
        - Написать и запустить тесты
        
        ---
        
        ## 1. Установка (локальное окружение)
        
        ```bash
        # Клонируем репозиторий
        git clone https://github.com/quark/platform.git
        cd platform
        
        # Устанавливаем зависимости
        npm install -g @quark/cli  # CLI для управления модулями
        
        # Запускаем всю систему
        docker-compose -f docs/examples/docker-compose.dev.yml up --build
        ```
        
        > ✅ После запуска проверь:
        > - `http://localhost:3001/health` — auth-service
        > - `http://localhost:3004/api/v1/posts` — blog-service
        > - `http://localhost:3005/ws` — messaging-service (WebSocket)
        
        ---
        
        ## 2. Структура проекта
        
        ```
        quark/
        ├── services/               # Микросервисы
        │   ├── auth-service/       # Авторизация (FastAPI)
        │   ├── blog-service/       # Блог (NestJS)
        │   ├── messaging-service/  # Мессенджер (NestJS + WebSocket)
        │   └── ...                 # Остальные сервисы
        ├── docs/                   # Вся документация
        ├── modules/                # Сторонние модули (после подключения)
        ├── docker-compose.dev.yml  # Локальный запуск
        └── quark-cli/              # CLI для разработчиков
        ```
        
        ---
        
        ## 3. Как создать и подключить модуль
        
        ### Шаг 1: Создай модуль с помощью CLI
        ```bash
        quark module:create my-seo-analyzer --type wasm
        ```
        
        ### Шаг 2: Изучи структуру
        ```
        my-seo-analyzer/
        ├── module-manifest.yaml    # Метаданные модуля
        ├── main.rs                 # Код на Rust (WASM)
        └── src/                    # Логика
        ```
        
        ### Шаг 3: Определи, на что подписываться
        В `module-manifest.yaml`:
        ```yaml
        name: my-seo-analyzer
        version: 1.0.0
        type: wasm
        runtime: wasmedge
        requires:
          - event_bus: nats
          - auth: jwt
        exposes:
          - events: seo.analysis.completed
        subscribes_to:
          - post.published
        ```
        
        ### Шаг 4: Реализуй логику (пример на Rust)
        ```rust
        #[no_mangle]
        pub extern "C" fn on_post_published(post_json: *const u8, len: usize) {
            let post: Post = parse_json(post_json, len);
            let score = analyze_seo(&post.content);
            
            publish_event("seo.analysis.completed", &json!({
                "post_id": post.id,
                "seo_score": score,
                "recommendations": ["add meta description", "improve headings"]
            }));
        }
        ```
        
        ### Шаг 5: Подключи к системе
        ```bash
        quark module:deploy ./my-seo-analyzer --env dev
        ```
        
        > ✅ Модуль появится в `Plugin Hub`, начнёт получать события `post.published`
        
        ---
        
        ## 4. Как запустить тесты
        
        ### Unit-тесты
        ```bash
        # Для auth-service (Python)
        cd services/auth-service
        pytest tests/unit/
        
        # Для blog-service (TypeScript)
        cd services/blog-service
        npm test
        ```
        
        ### Интеграционные тесты
        ```bash
        # Запуск всех интеграционных тестов
        pytest tests/integration/ --env local
        ```
        
        ### E2E-тесты
        ```bash
        npx playwright test
        ```
        
        ### Нагрузочные тесты
        ```bash
        k6 run docs/testing/load-test-scenarios/read-posts.js
        ```
        
        ---
        
        ## 5. Как запустить мониторинг
        
        После запуска `docker-compose`:
        - Открой **Grafana**: `http://localhost:3000` (логин: `admin`, пароль: `quark`)
        - Перейди в дашборды:
          - `Service Health`
          - `AI Ops Agent`
          - `Event Bus (NATS)`
        - Проверь, что все сервисы в статусе `UP`
        
        ---
        
        ## 6. Как внести изменения и создать PR
        
        1. Создай ветку:
           ```bash
           git checkout -b feature/seo-improvement
           ```
        
        2. Внеси изменения
        
        3. Протестируй:
           ```bash
           pytest && npm test
           ```
        
        4. Зафиксируй:
           ```bash
           git add .
           git commit -m "feat: add SEO analysis"
           ```
        
        5. Создай PR в GitHub
        
        6. Ожидай:
           - Автоматические тесты
           - Ревью от человека
           - Предложение от **AI Ops Agent** (если есть оптимизации)
        
        ---
        
        ## 7. Полезные ссылки
        
        | Документ | Назначение |
        |--------|-----------|
        | [`adr-003-module-docking.md`](/docs/adr/adr-003-module-docking.md) | Как работают модули |
        | [`api-governance.md`](/docs/api/api-governance.md) | Правила API |
        | [`threat-model-report.md`](/docs/security/threat-model-report.md) | Безопасность |
        | [`test-plan.md`](/docs/quality/test-plan.md) | Тестирование |
        | [`tech-matrix.md`](/docs/architecture/tech-matrix.md) | Почему выбраны эти технологии |
        
        ---
        
        ## ✅ Готов к старту?
        Если ты прошёл все шаги — ты официально **участник экосистемы Quark**.
        
        > 🌟 Добро пожаловать в будущее модульных, ИИ-нативных систем.
        
        ## Пример скрипта onboarding.sh
        
        ```bash
        # scripts/onboarding.sh
        #!/bin/bash
        echo "🚀 Запуск Quark MVP..."
        
        # Проверка зависимостей
        command -v docker-compose >/dev/null 2>&1 || { echo "Docker Compose не установлен"; exit 1; }
        
        # Запуск
        docker-compose -f docker-compose.dev.yml up --build -d
        
        echo "✅ Система запущена:"
        echo "   - Auth: http://localhost:3001/health"
        echo "   - Blog: http://localhost:3004/api/v1/posts"
        echo "   - Grafana: http://localhost:3000"
        
        # Проверка готовности
        sleep 10
        curl -f http://localhost:3001/health || echo "⚠️ auth-service не запущен"
        ```
          "
    ---privacy-policy.md---
          "
        # Политика конфиденциальности
        
        ## 1. Сбор данных
        Мы собираем:
        - Email, username
        - IP-адрес (временно)
        - Действия в системе (для анализа)
        
        ## 2. Использование
        - Для работы сервиса
        - Для улучшения ИИ
        - Без передачи третьим лицам
        
        ## 3. Права пользователей
        - Запрос на удаление данных
        - Отзыв согласия
        - Получение копии данных
        
        ## 4. Хранение
        - В РФ
        - Шифрование
        - Удаление по запросу
          "
    ---raci.md---
          "
        # RACI Matrix
        
        | Задача            | Ответственный (R) | Подотчётный (A) | Консультируемый (C) | Информируемый (I) |
        |-------------------|-------------------|-----------------|---------------------|-------------------|
        | Проектирование    | Qwen              | Человек         | Grok/Claude         | —                 |
        | Написание кода    | Qwen-Coder        | Человек         | —                   | —                 |
        | Деплой            | Qwen              | Человек         | —                   | —                 |
        | Одобрение решений | Человек           | —               | Qwen                | —                 |
          "
    ---README.md---
          "
        # 📚 Документация Quark
        
        > **Модульная, ИИ-нативная платформа для блогов и мессенджера**
        
        Этот каталог содержит **полную, согласованную и живую документацию** для системы **Quark** — высокодинамичной, масштабируемой платформы, спроектированной с участием ИИ и ориентированной на модульность, безопасность и автономность.
        
        ---
        
        ## 🗂️ Структура каталога
        
        ```
        docs/
        ├── ai/                     # ИИ-агенты, этика, мониторинг
        ├── api/                    # API, контракты, схемы
        ├── architecture/           # Архитектурные диаграммы и ADR
        ├── backup/                 # Резервное копирование
        ├── capacity-plan/          # Производительность и масштабируемость
        ├── data/                   # Модели данных и жизненный цикл
        ├── devops/                 # Мониторинг, SLO, disaster recovery
        ├── examples/               # Примеры модулей и кода
        ├── quality/                # Тестирование, ревью, метрики документации
        ├── security/               # Безопасность, compliance, инциденты
        ├── team/                   # Команда, процессы, onboarding
        ├── tools/                  # Автоматизация документации
        ├── templates/              # Шаблоны (post-mortem)
        └── other/                  # Прочие материалы (выбор LLM)
        ```
        
        ---
        
        ## 📚 Полный список документов
        
        ### 🤖 1. Искусственный интеллект (AI)
        | Файл | Описание |
        |------|---------|
        | [`ai/monitoring.md`](ai/monitoring.md) | Мониторинг ИИ: accuracy, latency, drift |
        | [`ai/ai-ops/ai-ops.md`](ai/ai-ops/ai-ops.md) | Общее описание AI Ops |
        | [`ai/ai-ops/ai-ops-agent.md`](ai/ai-ops/ai-ops-agent.md) | Агент по самооптимизации системы |
        | [`ai/ai-ops/workflow-example.md`](ai/ai-ops/workflow-example.md) | Пример workflow: AI предлагает исправление → PR |
        | [`ai/data-governance.md`](ai/data-governance.md) | Управление данными ИИ: согласие, аудит, шифрование |
        | [`ai/ethics-guidelines.md`](ai/ethics-guidelines.md) | Этические принципы: прозрачность, контроль, запрет на вред |
        | [`ai/model-lifecycle.md`](ai/model-lifecycle.md) | Жизненный цикл ИИ-моделей: обучение, деплой, мониторинг |
        
        ---
        
        ### 🌐 2. API и контракты
        | Файл | Описание |
        |------|---------|
        | [`api/api-governance.md`](api/api-governance.md) | Правила проектирования API |
        | [`api/asyncapi-events.yaml`](api/asyncapi-events.yaml) | Контракты событий (NATS) |
        | [`api/resource-schema.md`](api/resource-schema.md) | Общая структура ресурсов (посты, пользователи) |
        | [`api/openapi/auth-service.yaml`](api/openapi/auth-service.yaml) | OpenAPI для `auth-service` |
        | [`api/openapi/blog-service.yaml`](api/openapi/blog-service.yaml) | OpenAPI для `blog-service` |
        | [`api/openapi/messaging-service.yaml`](api/openapi/messaging-service.yaml) | OpenAPI для `messaging-service` |
        
        ---
        
        ### 🏗️ 3. Архитектура
        | Файл | Описание |
        |------|---------|
        | [`architecture/context.md`](architecture/context.md) | System Context Diagram (C4 Level 1) |
        | [`architecture/containers.md`](architecture/containers.md) | Container Diagram (C4 Level 2) |
        | [`architecture/components.md`](architecture/components.md) | Component Diagram (C4 Level 3) |
        | [`architecture/deployment.md`](architecture/deployment.md) | Deployment Diagram |
        | [`architecture/adr-001-nats-vs-kafka.md`](architecture/adr-001-nats-vs-kafka.md) | ADR: выбор NATS |
        | [`architecture/adr-002-event-driven.md`](architecture/adr-002-event-driven.md) | ADR: event-driven архитектура |
        | [`architecture/adr-003-module-docking.md`](architecture/adr-003-module-docking.md) | ADR: модульность по принципу "МКС" |
        | [`architecture/adr-004-ai-ops-agent.md`](architecture/adr-004-ai-ops-agent.md) | ADR: AI Ops Agent |
        | [`architecture/adr-005-jwt-auth.md`](architecture/adr-005-jwt-auth.md) | ADR: JWT как единый стандарт аутентификации |
        | [`architecture/adr-006-grpc.md`](architecture/adr-006-grpc.md) | ADR: использование gRPC для внутренних вызовов |
        | [`architecture/adr-007-wasm-modules.md`](architecture/adr-007-wasm-modules.md) | ADR: WebAssembly для безопасных модулей |
        | [`architecture/tech-matrix.md`](architecture/tech-matrix.md) | Сравнительная матрица технологий |
        
        ---
        
        ### 💾 4. Резервное копирование и восстановление
        | Файл | Описание |
        |------|---------|
        | [`backup/backup-strategy.md`](backup/backup-strategy.md) | Стратегия бэкапов: частота, хранилища |
        | [`backup/recovery-checklist.md`](backup/recovery-checklist.md) | Чек-лист восстановления после сбоя |
        
        ---
        
        ### 📈 5. Производительность и масштабируемость
        | Файл | Описание |
        |------|---------|
        | [`capacity-plan/bottleneck-analysis.md`](capacity-plan/bottleneck-analysis.md) | Анализ узких мест (NATS, PostgreSQL, AI) |
        | [`capacity-plan/capacity-plan.md`](capacity-plan/capacity-plan.md) | Расчёт ресурсов, RPS, масштабирование |
        
        ---
        
        ### 🧱 6. Модели данных
        | Файл | Описание |
        |------|---------|
        | [`data/data-lifecycle.md`](data/data-lifecycle.md) | Жизненный цикл данных: сроки хранения, удаление |
        | [`data/data-model.md`](data/data-model.md) | ER-диаграмма: связи между сущностями |
        | [`data/resource-schema.md`](data/resource-schema.md) | Структура данных (пост, пользователь, медиа) |
        | [`data/data-flow.md`](data/data-flow.md) | Data Flow Diagrams (DFD) |
        
        ---
        
        ### 🔐 7. Безопасность и соответствие
        | Файл | Описание |
        |------|---------|
        | [`security/threat-model-report.md`](security/threat-model-report.md) | Полный STRIDE-анализ угроз |
        | [`security/secure-arch-guidelines.md`](security/secure-arch-guidelines.md) | Руководство по безопасной архитектуре |
        | [`security/iam.md`](security/iam.md) | Управление доступом (JWT, RBAC) |
        | [`security/identity-access.md`](security/identity-access.md) | Детали аутентификации и авторизации |
        | [`security/compliance-checklist.md`](security/compliance-checklist.md) | Соответствие GDPR, ФЗ-152, ФЗ-149 |
        | [`security/disaster-recovery-plan.md`](security/disaster-recovery-plan.md) | План восстановления (RTO/RPO) |
        | [`security/incident-response.md`](security/incident-response.md) | Playbook реагирования на инциденты |
        
        ---
        
        ### 🧪 8. Качество и тестирование
        | Файл | Описание |
        |------|---------|
        | [`quality/test-plan.md`](quality/test-plan.md) | Полный план тестирования (unit, e2e, load) |
        | [`quality/code-review.md`](quality/code-review.md) | Правила код-ревью |
        | [`quality/testing-strategy.md`](quality/testing-strategy.md) | Стратегия тестирования |
        | [`quality/load-test-scenarios.md`](quality/load-test-scenarios.md) | Сценарии нагрузочного тестирования (k6) |
        | [`quality/PR Process.md`](quality/PR%20Process.md) | Процесс слияния кода (CI → ревью → деплой) |
        | [`quality/docs-metrics.md`](quality/docs-metrics.md) | SLO для документации (актуальность, покрытие) |
        
        ---
        
        ### 🛠️ 9. DevOps и эксплуатация
        | Файл | Описание |
        |------|---------|
        | [`devops/monitoring.md`](devops/monitoring.md) | Стратегия мониторинга (OpenTelemetry, Grafana) |
        | [`devops/slo.md`](devops/slo.md) | SLO, error budget, алертинг |
        
        ---
        
        ### 🧩 10. Примеры и шаблоны
        | Файл | Описание |
        |------|---------|
        | [`examples/module-template/module-manifest.yaml`](examples/module-template/module-manifest.yaml) | Шаблон manifest для модуля |
        | [`examples/module-template/main.py`](examples/module-template/main.py) | Пример кода модуля |
        | [`examples/ai-ops-event-publisher.py`](examples/ai-ops-event-publisher.py) | Пример: AI Ops → GitHub PR |
        | [`templates/incident-postmortem-template.md`](templates/incident-postmortem-template.md) | Шаблон post-mortem отчёта |
        
        ---
        
        ### 👥 11. Команда и процессы
        | Файл | Описание |
        |------|---------|
        | [`team/brd.md`](team/brd.md) | Бизнес-требования |
        | [`team/roadmap.md`](team/roadmap.md) | Дорожная карта (MVP → v2) |
        | [`team/team-charter.md`](team/team-charter.md) | Цели и ценности команды |
        | [`team/raci.md`](team/raci.md) | Матрица ответственности (с участием ИИ) |
        | [`team/onboarding.md`](team/onboarding.md) | Инструкция для новых разработчиков |
        | [`team/glossary.md`](team/glossary.md) | Глоссарий терминов |
        | [`team/srs.md`](team/srs.md) | Технические требования |
        | [`team/privacy-policy.md`](team/privacy-policy.md) | Политика конфиденциальности |
        
        ---
        
        ### 🔧 12. Инструменты и автоматизация
        | Файл | Описание |
        |------|---------|
        | [`tools/auto-docs.md`](tools/auto-docs.md) | Автоматическая генерация документации (Swagger, Buf, MkDocs) |
        
        ---
        
        ### 📦 13. Прочее
        | Файл | Описание |
        |------|---------|
        | [`other/LLM_choice.md`](other/LLM_choice.md) | Обоснование выбора LLM (Ollama, Llama 3, phi) |
        | [`ci-cd-pipeline.yml`](ci-cd-pipeline.yml) | Пример CI/CD pipeline |
        
        ---
        
        ## 🚀 Как использовать
        - 🔍 Начни с [`architecture/context.md`](architecture/context.md) — чтобы понять систему в целом
        - 📊 Перейди к [`architecture/containers.md`](architecture/containers.md) — чтобы увидеть сервисы
        - 🛠️ Изучи [`ai/ethics-guidelines.md`](ai/ethics-guidelines.md) и [`security/secure-arch-guidelines.md`](security/secure-arch-guidelines.md) — для безопасной разработки
        - 🧪 Ознакомься с [`quality/test-plan.md`](quality/test-plan.md) — перед внесением изменений
        - 🧩 Посмотри [`examples/module-template/`](examples/module-template/) — чтобы создать свой модуль
        
        ---
        
        ## ✅ Статус
        - [x] Все документы на месте
        - [x] Ссылки рабочие
        - [x] Готово к использованию в production
        
        > 💡 **Quark — это не просто платформа. Это экосистема будущего.**
          "
    ---roadmap.md---
          "
        # Roadmap
        
        ## Этап 1: MVP (2 недели)
        - auth-service
        - user-service
        - blog-service
        - API Gateway
        - Docker + Kubernetes
        
        ## Этап 2: Модульность (3 недели)
        - Plugin Hub
        - Module SDK
        - Docking Mechanism
        - Манифест модуля
        
        ## Этап 3: ИИ-интеграция (4 недели)
        - AI Orchestrator
        - AI Ops Agent
        - Генерация постов
        - Модерация
        
        ## Этап 4: Мобильное приложение (5 недель)
        - React Native
        - Quark Blog App
        - Quark Chat App
        - Push-уведомления
          "
    ---srs.md---
          "
        # SRS: Технические требования к системе Quark
        
        ## 1. Функциональные требования
        
        | ID | Требование |
        |----|-----------|
        | F-001 | Пользователь может зарегистрироваться и войти (JWT) |
        | F-002 | Пользователь может создать профиль и блог (`/user/username`) |
        | F-003 | Пользователь может публиковать посты (текст, медиа) |
        | F-004 | Пользователь может отправлять сообщения в мессенджере |
        | F-005 | ИИ может генерировать посты, модерировать, персонализировать |
        | F-006 | Сторонний разработчик может создать модуль и подключить его |
        | F-007 | Администратор может управлять модулями через панель |
        
        ## 2. Нефункциональные требования
        
        | ID | Требование |
        |----|-----------|
        | NF-001 | Производительность: < 500 мс на `/posts`, < 200 мс на `/user` |
        | NF-002 | Надёжность: 99.9% uptime |
        | NF-003 | Безопасность: соответствие ФЗ-152, шифрование трафика (TLS) |
        | NF-004 | Масштабируемость: поддержка до 100K пользователей |
        | NF-005 | Модульность: любой сервис может быть заменён без перезапуска системы |
        | NF-006 | Мониторинг: все метрики, трейсы, логи в OpenTelemetry + Grafana |
        | NF-007 | Обратная связь: ИИ может предлагать оптимизацию кода (AI Ops Agent) |
        | NF-008 | Локализация: поддержка i18n (готовность к переводу) |
          "
    ---team-charter.md---
          "
        # Team Charter
        
        ## Участники
        - **Архитектор/Постановщик задач**: Человек
        - **Разработчик/Архитектор/DevOps**: Qwen3-235B, Qwen3-Coder
        - **Консультанты**: Другие LLM (Grok, Claude и др.)
        
        ## Принципы
        - Все решения документируются
        - ИИ предлагает, человек одобряет
        - Эксперимент, а не production
        - Приоритет — модульность и автономность
          "
    --adr--
        ---adr-001-nats-vs-kafka.md---
              "
            # ADR-001: Выбор NATS JetStream вместо Apache Kafka
            
            ## Состояние
            Принято
            
            ## Контекст
            Нужно выбрать event bus для событийно-ориентированной архитектуры.
            
            ## Решение
            Выбран **NATS JetStream** вместо Kafka.
            
            ## Обоснование
            - Легковесность: NATS потребляет меньше ресурсов
            - Простота развёртывания: не требует ZooKeeper
            - Поддержка durable streams, replay, retention
            - Отличная производительность при малом и среднем масштабе
            - Подходит для эксперимента и MVP
            
            ## Альтернативы
            - Kafka: мощнее, но сложнее, избыточен для MVP
            - RabbitMQ: нет встроенной персистентности событий
            
            ## Последствия
            - При масштабировании > 1M сообщений/сек может потребоваться переход на Kafka
              "
        ---adr-002-event-driven.md---
              "
            # ADR-002: Event-Driven Architecture
            
            ## Состояние
            Принято
            
            ## Контекст
            Необходимо избежать прямых зависимостей между сервисами.
            
            ## Решение
            Все взаимодействия — через события (NATS).
            
            ## Обоснование
            - Полная независимость сервисов
            - Гибкость, расширяемость
            - Поддержка human-in-the-loop и AI Ops
            
            ## Последствия
            - Сложность диагностики — решается через OpenTelemetry
              "
        ---adr-003-module-docking.md---
              "
            # ADR-003: Модульность по принципу "МКС"
            
            ## Состояние
            Принято
            
            ## Контекст
            Нужно, чтобы сервисы были автономными и стыкуемыми.
            
            ## Решение
            Каждый сервис — модуль с `module-manifest.yaml`, health-check, OpenAPI.
            
            ## Обоснование
            - Параллельная разработка
            - Поддержка сторонних разработчиков
            - Возможность замены модулей
            
            ## Последствия
            - Необходимость строгих контрактов
              "
        ---adr-004-ai-ops-agent.md---
              "
            # ADR-004: AI Ops Agent
            
            ## Состояние
            Принято
            
            ## Контекст
            ИИ должен не только генерировать контент, но и обслуживать систему.
            
            ## Решение
            Создать `ai-ops-agent`, который анализирует метрики и предлагает исправления.
            
            ## Обоснование
            - Снижение нагрузки на DevOps
            - Самооптимизация системы
            - Обратная связь → обучение ИИ
            
            ## Последствия
            - Требуется human-in-the-loop
              "
        ---adr-005-jwt-auth.md---
              "
            # ADR-005: Единый формат аутентификации
            
            ## Состояние
            Принято
            
            ## Контекст
            Все сервисы должны понимать один "язык" авторизации.
            
            ## Решение
            Использовать JWT с полями `sub`, `roles`, `permissions`.
            
            ## Обоснование
            - Простота, масштабируемость
            - Поддержка RBAC
            - Совместимость с BFF и API Gateway
            
            ## Последствия
            - Необходимость централизованного управления секретами (Vault)
              "
        ---adr-006-grpc.md---
              "
            # ADR-006: Использование gRPC для внутренних вызовов между сервисами
            
            ## Состояние
            **Принято**
            
            ## Контекст
            В системе Quark используются два типа взаимодействия:
            1. **Асинхронные события** (через NATS) — для большинства сценариев
            2. **Синхронные вызовы** — когда нужен немедленный ответ (например, `ai-orchestrator` > `ai-writer`)
            
            Для синхронных вызовов необходимо выбрать **высокопроизводительный, типизированный протокол**, который:
            - Быстрее REST
            - Поддерживает строгую типизацию
            - Работает в условиях высокой нагрузки
            
            ## Решение
            Использовать **gRPC** для внутренних синхронных вызовов между сервисами.  
            **REST остаётся** для внешнего API.
            
            ### Примеры использования:
            - `ai-orchestrator` > `ai-writer` (генерация текста)
            - `blog-service` > `media-service` (проверка статуса загрузки)
            - `auth-service` > `user-service` (валидация профиля)
            
            ### Технологии:
            - **Протокол**: gRPC (HTTP/2 + Protocol Buffers)
            - **Генерация кода**: `protoc` + `buf`
            - **Сервисы**: `ai-writer`, `ai-moderator`, `media-service`
            
            ## Обоснование
            | Преимущество | Описание |
            |-------------|---------|
            | ? **Высокая производительность** | Бинарный формат (Protobuf) уменьшает размер сообщений на 60–80% по сравнению с JSON |
            | ? **Строгая типизация** | Ошибки выявляются на этапе компиляции, а не в рантайме |
            | ? **Поддержка потоков** | Подходит для ИИ-генерации (server streaming) |
            | ? **Генерация SDK** | Автоматическое создание клиентов на Python, TypeScript, Go |
            | ? **Встроенные таймауты и retry** | Упрощает обработку сетевых сбоев |
            
            > ?? Подтверждено в `giga-chat_ansver.txt`:  
            > _"gRPC — высокоэффективный фреймворк... высокая скорость передачи данных"_
            
            ## Альтернативы
            | Вариант | Почему не выбран |
            |--------|------------------|
            | **REST/JSON** | Медленнее, слабая типизация, больше трафика |
            | **GraphQL** | Избыточен для внутренних вызовов, сложнее кэшировать |
            | **Direct HTTP calls** | Нет контрактов, сложно тестировать |
            
            ## Последствия
            - ? Сервисы становятся **быстрее и надёжнее**
            - ? Требуется **централизованное управление `.proto` файлами** (реестр схем)
            - ? Сложнее отлаживать (нужен `grpcurl` или `BloomRPC`)
            - ?? Нужно **документировать endpoint’ы в OpenAPI через мост** (например, `grpc-gateway`)
            
            ## Связанные документы
            - `api-governance.md` — правила API
            - `module-manifest.yaml` — указание на `grpc` как на поддерживаемый протокол
            - `tech-matrix.md` — сравнение технологий
              "
        ---adr-007-wasm-modules.md---
              "
            # ADR-007: Поддержка WebAssembly для безопасных пользовательских модулей
            
            ## Состояние
            **Принято**
            
            ## Контекст
            Quark позволяет сторонним разработчикам создавать **пользовательские модули** (например, `seo-analyzer`, `telegram-bridge`).
            
            Проблема:
            - Docker-модули **требуют высоких привилегий**
            - Есть риск **выполнения вредоносного кода**
            - Сложно **ограничить доступ к системе**
            
            Необходимо предложить **более безопасную альтернативу** для **небольших, изолированных модулей**.
            
            ## Решение
            Поддерживать **WebAssembly (WASM)** как **дополнительный формат модулей** наравне с Docker.
            
            ### Примеры использования:
            - `seo-analyzer` — анализирует текст и возвращает рекомендации
            - `ai-summarizer-light` — краткая генерация на основе промпта
            - `custom-filter` — пользовательский фильтр для ленты
            
            ### Технологии:
            - **Языки**: Rust, Go, AssemblyScript
            - **Песочница**: WasmEdge, Wasmer
            - **API**: доступ только к:
              - HTTP-клиенту (ограниченный)
              - Чтению входных данных
              - Отправке событий через `event-publisher`
            
            ## Обоснование
            | Преимущество | Описание |
            |-------------|---------|
            | ✅ **Высокая безопасность** | WASM выполняется в изолированной песочнице, без доступа к сети, файловой системе |
            | ✅ **Быстрый запуск** | Мгновенная инициализация (микросекунды) |
            | ✅ **Кроссплатформенность** | Работает на любом хосте с WASM-рантаймом |
            | ✅ **Малый размер** | Бинарники в разы меньше Docker-образов |
            | ✅ **Поддержка LLM-агентов** | Лёгкие ИИ-агенты могут работать в WASM |
            
            > 📌  _"WebAssembly позволяет запускать код в песочнице, обеспечивая безопасность и изоляцию"_
            
            ## Альтернативы
            | Вариант | Почему не выбран |
            |--------|------------------|
            | **Только Docker** | Избыточен для простых модулей, выше риски |
            | **Jail для Python/Node** | Менее надёжная изоляция |
            | **Отказ от сторонних модулей** | Противоречит цели — открытая экосистема |
            
            ## Последствия
            - ✅ Повышается **безопасность платформы**
            - ✅ Упрощается **вход для разработчиков** (можно писать на Rust/Go)
            - ❌ Не подходит для **тяжёлых задач** (обработка видео, LLM)
            - ❌ Требуется **новый `module-runner`** для WASM
            - 🟡 Нужно **обновить `module-manifest.yaml`**:
              ```yaml
              type: wasm | docker
              runtime: wasmedge
              permissions:
                - http:outbound
                - events:publish
              ```
              "
    --ai--
        ---data-governance.md---
              "
            # Управление данными ИИ
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Обеспечить **этичное, безопасное и прозрачное использование данных** в ИИ-агентах Quark, с соблюдением прав пользователей и требований регуляторов (GDPR, ФЗ-152).
            
            ---
            
            ## 1. Принципы
            
            | Принцип | Описание |
            |--------|--------|
            | **Сбор только с согласия** | Пользователь явно даёт согласие на использование его данных для обучения ИИ |
            | **Минимизация данных** | ИИ получает только необходимые данные (например, текст поста, а не весь профиль) |
            | **Владение данными** | Пользователь остаётся владельцем своих данных |
            | **Прозрачность** | Пользователь знает, когда и зачем используется ИИ |
            | **Шифрование** | Данные ИИ шифруются при хранении и передаче |
            
            ---
            
            ## 2. Типы данных ИИ
            
            | Данные | Использование | Хранение | Шифрование |
            |-------|--------------|---------|-----------|
            | **Контекст диалога** | Генерация ответов в мессенджере | Redis (временно) | Да (TLS + at rest) |
            | **Текст постов** | Обучение персонализированного ИИ | PostgreSQL (согласие) | Да |
            | **Промпты пользователя** | Оптимизация генерации | PostgreSQL | Да |
            | **Реакции на ИИ-контент** | Обучение модели | PostgreSQL | Да |
            | **Метаданные** | Аналитика (без PII) | PostgreSQL | Нет |
            
            > 🔐 **PII (персональные данные)** никогда не передаются в LLM напрямую.
            
            ---
            
            ## 3. Политики хранения
            
            | Данные | Срок хранения | Действие после истечения |
            |-------|----------------|--------------------------|
            | Контекст диалога | 1 час | Автоматическое удаление |
            | Текст постов (для обучения) | 5 лет (с согласия) | Архивация |
            | Промпты | 2 года | Архивация |
            | Реакции | 3 года | Архивация |
            | Логи использования ИИ | 30 дней | Удаление |
            
            > 📅 Сроки могут быть изменены пользователем через настройки.
            
            ---
            
            ## 4. Аудит использования данных
            
            ### 4.1. Что аудируется
            - Какой ИИ-агент использовал данные
            - Какие данные были переданы
            - Когда и зачем
            - Результат (сгенерированный контент)
            
            ### 4.2. Где хранится аудит
            ```json
            {
              "audit_id": "audit-123",
              "user_id": "user-456",
              "ai_agent": "ai-writer",
              "data_used": ["post_id", "prompt"],
              "timestamp": "2025-04-05T10:00:00Z",
              "purpose": "content_generation",
              "response_hash": "sha256:abc123..."
            }
            ```
            → Хранится в `audit-log` (PostgreSQL)
            
            ### 4.3. Доступ к аудиту
            - **Пользователь**: может запросить отчёт
            - **Администратор**: полный доступ
            - **ИИ**: только для self-audit (через `ai-ops-agent`)
            
            ---
            
            ## 5. Процедура отзыва согласия
            
            Пользователь может:
            - Отозвать согласие на использование данных для обучения ИИ
            - Удалить свои данные из ИИ-систем
            
            ### Процесс:
            1. Пользователь нажимает "Отозвать согласие" в настройках
            2. Система:
               - Помечает данные как "на удаление"
               - Удаляет контекст из Redis
               - Помечает посты как "не для обучения"
               - Удаляет из векторной базы (если используется)
            3. Через 7 дней — физическое удаление
            4. Пользователь получает подтверждение
            
            > ✅ Соответствует **GDPR (право на забвение)** и **ФЗ-152**
            
            ---
            
            ## 6. Шифрование данных ИИ
            
            | Уровень | Технология | Описание |
            |--------|-----------|---------|
            | **In Transit** | TLS 1.3 | Все вызовы к `ai-orchestrator`, `ai-writer` |
            | **At Rest (Redis)** | AES-256 | Контекст диалогов шифруется перед сохранением |
            | **At Rest (PostgreSQL)** | TDE (Transparent Data Encryption) | Для данных обучения |
            | **Контекст в памяти** | Обнуление после использования | После генерации — очистка |
            
            ---
            
            ## 7. Ответственные
            | Роль | Ответственность |
            |------|-----------------|
            | **Пользователь** | Даёт/отзывает согласие |
            | **AI Ops Agent** | Мониторинг использования данных |
            | **Администратор** | Управление политиками |
            | **DevOps** | Настройка шифрования |
              "
        ---ethics-guidelines.md---
              "
            # Этические принципы ИИ в Quark
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Обеспечить **ответственное, прозрачное и безопасное использование ИИ**, защищая пользователей от вреда и манипуляций.
            
            ---
            
            ## 1. Принципы
            
            | Принцип | Описание |
            |--------|--------|
            | **Прозрачность** | Пользователь всегда знает, когда взаимодействует с ИИ |
            | **Контроль** | Человек всегда может отменить, отредактировать или отклонить действие ИИ |
            | **Безопасность** | ИИ не генерирует контент, нарушающий законы или этику |
            | **Ответственность** | Ответственность за действия ИИ несёт человек, а не алгоритм |
            | **Справедливость** | ИИ не дискриминирует по признакам: пол, раса, возраст, ориентация |
            | **Конфиденциальность** | ИИ не запоминает и не передаёт персональные данные |
            
            ---
            
            ## 2. Конкретные правила
            
            ### 2.1. Прозрачность
            - ✅ Все ответы ИИ помечаются: "**Ответ сгенерирован ИИ**"
            - ✅ В настройках — переключатель: "Показывать метки ИИ"
            - ✅ При генерации поста — кнопка: "Это написал ИИ"
            
            ### 2.2. Запрещённый контент
            ИИ **не должен генерировать**:
            - ❌ Контент, призывающий к насилию
            - ❌ Ненавистнические высказывания
            - ❌ Фейки и дезинформация
            - ❌ Сексуальный контент (NSFW)
            - ❌ Инструкции по созданию оружия
            - ❌ Автоматические спам-сообщения
            
            ### 2.3. Контроль
            - ✅ Все предложения ИИ — с кнопкой "Одобрить", "Редактировать", "Отклонить"
            - ✅ ИИ не может самостоятельно публиковать, удалять, модерировать
            - ✅ Человек — последний рубеж контроля
            
            ### 2.4. Ответственность
            - ✅ За модерацию — человек
            - ✅ За публикацию — человек
            - ✅ За настройки ИИ — человек
            - ✅ ИИ — инструмент, не замена
            
            ---
            
            ## 3. Процессы
            
            ### 3.1. Обучение ИИ
            - ✅ Только на данных с согласия пользователя
            - ✅ Аннотация — людьми или ИИ с проверкой
            - ✅ Никаких PII в обучающей выборке
            
            ### 3.2. Модерация
            - ✅ ИИ предлагает — человек решает
            - ✅ При сомнениях — на ручную проверку
            - ✅ Возможность обжалования решения
            
            ### 3.3. Обратная связь
            - ✅ Кнопка "Пожаловаться на ИИ"
            - ✅ Сбор данных для улучшения
            - ✅ Feedback loop: "Это было полезно?" (👍/👎)
            
            ---
            
            ## 4. Нарушения
            При выявлении нарушения:
            1. ИИ-агент отключается
            2. Уведомление команде
            3. Анализ причины
            4. Обновление фильтров
            5. Post-mortem
            
              "
        ---model-lifecycle.md---
              "
            # Жизненный цикл ИИ-моделей
            
            1. **Сбор данных** — только с согласия
            2. **Аннотация** — людьми или ИИ с проверкой
            3. **Обучение** — в изолированной среде
            4. **Валидация** — тест на эталонных данных
            5. **Деплой** — через CI/CD
            6. **Мониторинг** — drift, accuracy
            7. **Обновление** — при падении качества
              "
        ---monitoring.md---
              "
            # Мониторинг ИИ
            
            | Метрика        | Цель  |
            |----------------|-------|
            | Accuracy       | > 85% |
            | Latency        | < 2s  |
            | Data Drift     | < 10% |
            | Explainability | > 70% |
              "
        --ai-ops--
            ---ai-ops-agent.md---
                  "
                # AI Ops Agent: Агент по самооптимизации системы
                
                ## Задачи
                | Задача | Описание |
                |-------|--------|
                | **Мониторинг системы** | Подключается к OpenTelemetry, Grafana, получает трейсы, метрики, логи |
                | **Генерация изменений в коде** | При обнаружении проблемы (например, высокая задержка) — предлагает исправление |
                | **Предложения по улучшению архитектуры** | Анализирует ADR, предлагает: "Заменить REST на gRPC для `ai-orchestrator`" |
                
                ## Пример работы
                1. Grafana фиксирует: `latency > 2s` в `media-service`
                2. AI Ops Agent:
                   - Анализирует трейс
                   - Находит: `resize_image` — синхронная функция
                   - Генерирует код: `async def resize_image_async(...)`
                   - Создаёт PR с описанием: "Переписать на async для снижения блокировок"
                3. Человек: одобряет → мердж
                
                ## Безопасность
                - Никаких прямых деплоев
                - Все изменения — с объяснением
                - Поддержка feedback loop
                  "
            ---ai-ops.md---
                  "
                # AI Ops: Автоматизация операций с помощью ИИ
                
                ## Цель
                Использовать ИИ для автоматизации DevOps-задач, снижая нагрузку на команду и ускоряя улучшение системы.
                
                ## Функциональность
                
                | Функция | Описание |
                |--------|--------|
                | **Автоматическое обновление зависимостей** | ИИ анализирует новые версии библиотек, проверяет совместимость, создаёт PR |
                | **Генерация кода для новых фич** | На основе описания (например, "добавить лайки к посту") ИИ генерирует код, тесты, миграции |
                | **Оптимизация производительности** | ИИ анализирует метрики, предлагает: кэширование, индексы, async обработку |
                
                ## Принципы
                - Все изменения — через Pull Request
                - Человек всегда одобряет
                - История изменений сохраняется
                  "
            ---workflow-example.md---
                  "
                # Пример: AI Ops Agent предлагает оптимизацию
                
                ## Сценарий
                - Grafana фиксирует: `latency > 2s` в `media-service`
                - AI Ops Agent:
                  1. Находит: `resize_image` — синхронная функция
                  2. Генерирует асинхронную версию
                  3. Создаёт PR
                
                ## PR: "Переписать resize_image на async"
                
                ```python
                # Было
                def resize_image(image, size):
                    return PIL.Image.resize(image, size)
                
                # Стало
                async def resize_image_async(image, size):
                    loop = asyncio.get_event_loop()
                    return await loop.run_in_executor(None, resize_image, image, size)
                ```
                
                ## Обоснование
                - Снижает блокировку event loop
                - Увеличивает throughput на 3x
                
                ## Тесты
                ```python
                def test_resize_async():
                    result = await resize_image_async(test_image, (800, 600))
                    assert result.size == (800, 600)
                  "
    --api--
        ---api-governance.md---
              "
            # Правила API
            
            - Версионирование: /v1/
            - Ошибки: { "error": "...", "code": 400 }
            - Rate Limit: 1000 req/hour
            - Безопасность: JWT
              "
        ---asyncapi-events.yaml---
              "
            asyncapi: 2.6.0
            info:
              title: Quark Events
              version: 1.0.0
            channels:
              user.created:
                publish:
                  message:
                    payload:
                      type: object
                      properties:
                        id: { type: string }
                        email: { type: string }
              "
        ---resource-schema.md---
              "
            # Resource Schema
            
            ## Blog Post
            ```json
            {
              "id": "string",
              "title": "string",
              "content": "string",
              "authorId": "string"
            }
            ```
              "
        --openapi--
            ---auth-service.yaml---
                  "
                openapi: 3.0.0
                info:
                  title: Auth Service API
                  version: v1
                  description: Служба аутентификации и управления сессиями
                
                servers:
                  - url: http://localhost:3001
                    description: Development Server
                  - url: https://api.quark.com
                    description: Production
                
                components:
                  securitySchemes:
                    BearerAuth:
                      type: http
                      scheme: bearer
                      bearerFormat: JWT
                
                  schemas:
                    LoginRequest:
                      type: object
                      required:
                        - email
                        - password
                      properties:
                        email:
                          type: string
                          format: email
                          example: user@quark.ai
                        password:
                          type: string
                          format: password
                          example: mysecretpassword
                
                    LoginResponse:
                      type: object
                      properties:
                        access_token:
                          type: string
                          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
                        token_type:
                          type: string
                          example: bearer
                        expires_in:
                          type: integer
                          example: 900
                
                    RegisterRequest:
                      type: object
                      required:
                        - email
                        - password
                        - username
                      properties:
                        email:
                          type: string
                          format: email
                        password:
                          type: string
                          format: password
                        username:
                          type: string
                          minLength: 3
                          maxLength: 30
                          pattern: '^[a-zA-Z0-9_-]+$'
                          example: alex_dev
                
                    RegisterResponse:
                      type: object
                      properties:
                        user_id:
                          type: string
                          example: user-123abc
                        username:
                          type: string
                        email:
                          type: string
                
                    ValidateTokenResponse:
                      type: object
                      properties:
                        valid:
                          type: boolean
                        user_id:
                          type: string
                        roles:
                          type: array
                          items:
                            type: string
                        exp:
                          type: integer
                
                security:
                  - BearerAuth: []
                
                paths:
                  /auth/login:
                    post:
                      summary: Вход пользователя
                      tags:
                        - Authentication
                      requestBody:
                        required: true
                        content:
                          application/json:
                            schema:
                              $ref: '#/components/schemas/LoginRequest'
                      responses:
                        '200':
                          description: Успешный вход
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/LoginResponse'
                        '401':
                          description: Неверные учетные данные
                
                  /auth/register:
                    post:
                      summary: Регистрация нового пользователя
                      tags:
                        - Authentication
                      requestBody:
                        required: true
                        content:
                          application/json:
                            schema:
                              $ref: '#/components/schemas/RegisterRequest'
                      responses:
                        '201':
                          description: Пользователь создан
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/RegisterResponse'
                        '400':
                          description: Неверный формат данных
                        '409':
                          description: Пользователь с таким email или username уже существует
                
                  /auth/validate:
                    get:
                      summary: Проверка JWT токена
                      tags:
                        - Authentication
                      security:
                        - BearerAuth: []
                      responses:
                        '200':
                          description: Токен валиден
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/ValidateTokenResponse'
                        '401':
                          description: Токен недействителен или истёк
                  "
            ---blog-service.yaml---
                  "
                openapi: 3.0.0
                info:
                  title: Blog Service API
                  version: v1
                  description: Управление постами, блогами и комментариями
                
                servers:
                  - url: http://localhost:3004
                    description: Development Server
                  - url: https://api.quark.com
                    description: Production
                
                components:
                  securitySchemes:
                    BearerAuth:
                      type: http
                      scheme: bearer
                      bearerFormat: JWT
                
                  schemas:
                    BlogPost:
                      type: object
                      properties:
                        id:
                          type: string
                        title:
                          type: string
                        content:
                          type: string
                        author_id:
                          type: string
                        created_at:
                          type: string
                          format: date-time
                        updated_at:
                          type: string
                          format: date-time
                        status:
                          type: string
                          enum: [draft, published]
                          default: draft
                
                    CreatePostRequest:
                      type: object
                      required:
                        - title
                        - content
                      properties:
                        title:
                          type: string
                          maxLength: 150
                        content:
                          type: string
                        status:
                          type: string
                          enum: [draft, published]
                          default: draft
                
                    UpdatePostRequest:
                      type: object
                      properties:
                        title:
                          type: string
                          maxLength: 150
                        content:
                          type: string
                        status:
                          type: string
                          enum: [draft, published]
                
                    ErrorResponse:
                      type: object
                      properties:
                        error:
                          type: string
                        code:
                          type: integer
                
                security:
                  - BearerAuth: []
                
                paths:
                  /api/v1/posts:
                    get:
                      summary: Получить список постов
                      tags:
                        - Posts
                      parameters:
                        - name: limit
                          in: query
                          schema:
                            type: integer
                            minimum: 1
                            maximum: 100
                            default: 20
                        - name: offset
                          in: query
                          schema:
                            type: integer
                            default: 0
                        - name: status
                          in: query
                          schema:
                            type: string
                            enum: [draft, published]
                      responses:
                        '200':
                          description: Список постов
                          content:
                            application/json:
                              schema:
                                type: array
                                items:
                                  $ref: '#/components/schemas/BlogPost'
                
                    post:
                      summary: Создать новый пост
                      tags:
                        - Posts
                      security:
                        - BearerAuth: []
                      requestBody:
                        required: true
                        content:
                          application/json:
                            schema:
                              $ref: '#/components/schemas/CreatePostRequest'
                      responses:
                        '201':
                          description: Пост создан
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/BlogPost'
                        '400':
                          description: Ошибка валидации
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/ErrorResponse'
                        '401':
                          description: Неавторизован
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/ErrorResponse'
                
                  /api/v1/posts/{id}:
                    get:
                      summary: Получить пост по ID
                      tags:
                        - Posts
                      parameters:
                        - name: id
                          in: path
                          required: true
                          schema:
                            type: string
                      responses:
                        '200':
                          description: Пост найден
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/BlogPost'
                        '404':
                          description: Пост не найден
                
                    put:
                      summary: Обновить пост
                      tags:
                        - Posts
                      security:
                        - BearerAuth: []
                      parameters:
                        - name: id
                          in: path
                          required: true
                          schema:
                            type: string
                      requestBody:
                        required: true
                        content:
                          application/json:
                            schema:
                              $ref: '#/components/schemas/UpdatePostRequest'
                      responses:
                        '200':
                          description: Пост обновлён
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/BlogPost'
                        '403':
                          description: Нет прав на редактирование
                        '404':
                          description: Пост не найден
                
                    delete:
                      summary: Удалить пост
                      tags:
                        - Posts
                      security:
                        - BearerAuth: []
                      parameters:
                        - name: id
                          in: path
                          required: true
                          schema:
                            type: string
                      responses:
                        '204':
                          description: Пост удалён
                        '403':
                          description: Нет прав
                        '404':
                          description: Пост не найден
                  "
            ---messaging-service.yaml---
                  "
                openapi: 3.0.0
                info:
                  title: Messaging Service API
                  version: v1
                  description: Управление диалогами и сообщениями
                
                servers:
                  - url: http://localhost:3005
                    description: Development Server
                  - url: https://api.quark.com
                    description: Production
                
                components:
                  securitySchemes:
                    BearerAuth:
                      type: http
                      scheme: bearer
                      bearerFormat: JWT
                
                  schemas:
                    Message:
                      type: object
                      properties:
                        id:
                          type: string
                        sender_id:
                          type: string
                        receiver_id:
                          type: string
                        content:
                          type: string
                        timestamp:
                          type: string
                          format: date-time
                        is_read:
                          type: boolean
                          default: false
                
                    SendMessageRequest:
                      type: object
                      required:
                        - receiver_id
                        - content
                      properties:
                        receiver_id:
                          type: string
                        content:
                          type: string
                          maxLength: 5000
                
                    Conversation:
                      type: object
                      properties:
                        user_id:
                          type: string
                        last_message:
                          $ref: '#/components/schemas/Message'
                        unread_count:
                          type: integer
                          minimum: 0
                
                security:
                  - BearerAuth: []
                
                paths:
                  /api/v1/messages:
                    get:
                      summary: Получить список диалогов (последние сообщения)
                      tags:
                        - Messaging
                      security:
                        - BearerAuth: []
                      responses:
                        '200':
                          description: Список диалогов
                          content:
                            application/json:
                              schema:
                                type: array
                                items:
                                  $ref: '#/components/schemas/Conversation'
                
                    post:
                      summary: Отправить сообщение
                      tags:
                        - Messaging
                      security:
                        - BearerAuth: []
                      requestBody:
                        required: true
                        content:
                          application/json:
                            schema:
                              $ref: '#/components/schemas/SendMessageRequest'
                      responses:
                        '201':
                          description: Сообщение отправлено
                          content:
                            application/json:
                              schema:
                                $ref: '#/components/schemas/Message'
                        '400':
                          description: Ошибка валидации
                        '404':
                          description: Получатель не найден
                
                  /api/v1/messages/{user_id}:
                    get:
                      summary: Получить сообщения с пользователем
                      tags:
                        - Messaging
                      security:
                        - BearerAuth: []
                      parameters:
                        - name: user_id
                          in: path
                          required: true
                          schema:
                            type: string
                        - name: limit
                          in: query
                          schema:
                            type: integer
                            default: 50
                        - name: offset
                          in: query
                          schema:
                            type: integer
                            default: 0
                      responses:
                        '200':
                          description: Список сообщений
                          content:
                            application/json:
                              schema:
                                type: array
                                items:
                                  $ref: '#/components/schemas/Message'
                
                  /api/v1/messages/{id}/read:
                    post:
                      summary: Отметить сообщение как прочитанное
                      tags:
                        - Messaging
                      security:
                        - BearerAuth: []
                      parameters:
                        - name: id
                          in: path
                          required: true
                          schema:
                            type: string
                      responses:
                        '204':
                          description: Сообщение отмечено как прочитанное
                        '403':
                          description: Нет прав
                        '404':
                          description: Сообщение не найдено
                
                  /ws:
                    get:
                      summary: WebSocket для реального времени
                      description: |
                        Подключение к WebSocket для получения сообщений в реальном времени.
                        Аутентификация через JWT в URL: `?token=...`
                      tags:
                        - Real-time
                      responses:
                        '101':
                          description: Переключение протоколов
                  "
    --architecture--
        ---components-auth.md---
              "
            # C4 Model: Component Diagram — Auth Service
            
            ## Описание
            Детализация внутренних компонентов `auth-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: Auth Service
            
                Container_Boundary(auth_service, "Auth Service") {
                    Component(login_controller, "LoginController", "HTTP", "Обработка /auth/login")
                    Component(register_controller, "RegisterController", "HTTP", "Обработка /auth/register")
                    Component(auth_service_logic, "AuthService", "Business Logic", "Валидация, генерация JWT")
                    Component(user_repository, "UserRepository", "PostgreSQL", "CRUD пользователей")
                    Component(jwt_generator, "JWTGenerator", "JWT", "Создание и валидация токенов")
                    Component(email_client, "EmailClient", "SMTP", "Отправка писем (верификация)")
                    Component(rate_limiter, "RateLimiter", "Redis", "Ограничение попыток входа")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(user_service, "User Service", "NestJS")
                Container(postgres, "PostgreSQL", "БД пользователей")
                Container(redis, "Redis", "Кэш, rate limiting")
                Container(email_service, "Email Service", "SMTP")
            
                Rel(gateway, login_controller, "POST /auth/login")
                Rel(gateway, register_controller, "POST /auth/register")
                Rel(login_controller, auth_service_logic, "validateCredentials()")
                Rel(register_controller, auth_service_logic, "createUser()")
                Rel(auth_service_logic, user_repository, "Сохранение/чтение")
                Rel(user_repository, postgres, "SQL")
                Rel(auth_service_logic, jwt_generator, "generateJWT()")
                Rel(jwt_generator, login_controller, "access_token")
                Rel(auth_service_logic, email_client, "sendVerificationEmail()")
                Rel(email_client, email_service, "SMTP")
                Rel(login_controller, rate_limiter, "checkRateLimit()")
                Rel(rate_limiter, redis, "INCR / EXPIRE")
            ```
            
            ## Компоненты
            | Компонент | Ответственность |
            |---------|-----------------|
            | `LoginController` | HTTP-интерфейс для входа |
            | `RegisterController` | HTTP-интерфейс для регистрации |
            | `AuthService` | Бизнес-логика: валидация, хеширование пароля |
            | `UserRepository` | Работа с БД |
            | `JWTGenerator` | Подпись и валидация токенов |
            | `EmailClient` | Отправка писем (верификация) |
            | `RateLimiter` | Защита от брутфорса |
            
            ## Цель
            - Показать, как реализуется безопасность и масштабируемость
            - Поддержать стандарты из `secure-arch-guidelines.md`
            - Готовность к интеграции с `user-service` и `plugin-hub`
              "
        ---components-blog.md---
              "
            # C4 Model: Component Diagram — Blog Service
            
            ## Описание
            Детализация внутренних компонентов `blog-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: Blog Service
            
                Container_Boundary(blog_service, "Blog Service") {
                    Component(blog_controller, "BlogController", "HTTP", "Обработка /posts, /blogs")
                    Component(blog_service_logic, "BlogService", "Business Logic", "Создание, публикация, права")
                    Component(blog_repository, "BlogRepository", "PostgreSQL", "CRUD операции с постами")
                    Component(media_client, "MediaServiceClient", "gRPC", "Загрузка изображений")
                    Component(event_publisher, "EventPublisher", "NATS", "Отправка post.published")
                    Component(ai_client, "AIOrchestratorClient", "HTTP", "Запрос генерации/модерации")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(media_service, "Media Service", "FastAPI")
                Container(ai_orchestrator, "AI Orchestrator", "FastAPI")
                Container(event_bus, "Event Bus", "NATS")
                Container(postgres, "PostgreSQL", "БД постов")
            
                Rel(gateway, blog_controller, "HTTP POST /posts")
                Rel(blog_controller, blog_service_logic, "Вызов метода")
                Rel(blog_service_logic, blog_repository, "Сохранение/чтение")
                Rel(blog_repository, postgres, "SQL")
                Rel(blog_service_logic, media_client, "Загрузка медиа")
                Rel(media_client, media_service, "gRPC UploadImage")
                Rel(blog_service_logic, event_publisher, "publish(post.published)")
                Rel(event_publisher, event_bus, "NATS publish")
                Rel(blog_service_logic, ai_client, "moderate(content)")
                Rel(ai_client, ai_orchestrator, "HTTP /ai/moderate")
            ```
            
            ## Компоненты
            
            | Компонент					| Ответственность 								|
            |---------------------------|-----------------------------------------------|
            | `BlogController` 			| Обработка HTTP-запросов `/posts`, `/blogs` 	|
            | `BlogService` 			| Бизнес-логика: создание, публикация, права 	|
            | `BlogRepository` 			| Работа с PostgreSQL							|
            | `MediaServiceClient` 		| Вызов `media-service` через gRPC 				|
            | `EventPublisher` 			| Отправка `post.published` в NATS 				|
            | `AIOrchestratorClient` 	| Запрос генерации/модерации у ИИ 				|
            
            ## Диаграмма (текстовая)
            [Web App] → [API Gateway] → [BlogController]
                                         ↓
                                 [BlogService]
                                     ↓     ↓
                        [BlogRepository]   [MediaServiceClient]
                                     ↓     ↓
                                 [EventPublisher] → NATS
                                     ↓
                         [AIOrchestratorClient] → ai-orchestrator
            
            ## Цель
            - Поддержка гибридного режима (блог + соцсеть)
            - Интеграция с ИИ и медиа
            - Готовность к поиску и уведомлениям
              "
        ---components-media.md---
              "
            # C4 Model: Component Diagram — Media Service
            
            ## Описание
            Детализация внутренних компонентов `media-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: Media Service
            
                Container_Boundary(media_service, "Media Service") {
                    Component(upload_controller, "UploadController", "HTTP", "POST /media/upload")
                    Component(media_processor, "MediaProcessor", "Business Logic", "Валидация, конвертация")
                    Component(thumbnail_generator, "ThumbnailGenerator", "FFmpeg", "Создание превью")
                    Component(storage_client, "StorageClient", "S3 API", "Загрузка в MinIO")
                    Component(event_publisher, "EventPublisher", "NATS", "Отправка media.uploaded")
                    Component(auth_client, "AuthServiceClient", "HTTP", "Валидация JWT")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(auth_service, "Auth Service", "FastAPI")
                Container(nats, "NATS JetStream", "Event Bus")
                Container(minio, "MinIO", "Хранение медиа")
            
                Rel(gateway, upload_controller, "POST /media/upload")
                Rel(upload_controller, auth_client, "validateToken()")
                Rel(auth_client, auth_service, "HTTP /auth/validate")
                Rel(upload_controller, media_processor, "process()")
                Rel(media_processor, thumbnail_generator, "generateThumbnail()")
                Rel(media_processor, storage_client, "upload()")
                Rel(storage_client, minio, "S3 PutObject")
                Rel(media_processor, event_publisher, "publish(media.uploaded)")
                Rel(event_publisher, nats, "NATS publish")
            ```
            
            ## Компоненты
            | Компонент | Ответственность |
            |---------|-----------------|
            | `UploadController` | Приём файлов |
            | `MediaProcessor` | Валидация, обработка |
            | `ThumbnailGenerator` | Создание превью |
            | `StorageClient` | Загрузка в MinIO |
            | `EventPublisher` | Публикация событий |
            | `AuthServiceClient` | Проверка JWT |
            
            ## Цель
            - Безопасная загрузка медиа
            - Поддержка больших файлов
            - Интеграция с `blog-service` и `ai-orchestrator`
              "
        ---components-messaging.md---
              "
            # C4 Model: Component Diagram — Messaging Service
            
            ## Описание
            Детализация внутренних компонентов `messaging-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: Messaging Service
            
                Container_Boundary(messaging_service, "Messaging Service") {
                    Component(ws_gateway, "WebSocketGateway", "WS", "Подключение клиентов")
                    Component(message_controller, "MessageController", "HTTP", "Отправка сообщений")
                    Component(message_service, "MessageService", "Business Logic", "Валидация, маршрутизация")
                    Component(message_repository, "MessageRepository", "PostgreSQL", "Хранение сообщений")
                    Component(conversation_service, "ConversationService", "Business Logic", "Управление диалогами")
                    Component(event_publisher, "EventPublisher", "NATS", "Отправка message.sent")
                    Component(auth_client, "AuthServiceClient", "HTTP", "Валидация JWT")
                    Component(rate_limiter, "RateLimiter", "Redis", "Ограничение сообщений")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(auth_service, "Auth Service", "FastAPI")
                Container(nats, "NATS JetStream", "Event Bus")
                Container(postgres, "PostgreSQL", "БД сообщений")
                Container(redis, "Redis", "Rate limiting, сессии")
            
                Rel(gateway, ws_gateway, "WS /ws?token=...")
                Rel(gateway, message_controller, "POST /messages")
                Rel(ws_gateway, message_service, "onMessage()")
                Rel(message_controller, message_service, "sendMessage()")
                Rel(message_service, message_repository, "Сохранение")
                Rel(message_repository, postgres, "SQL")
                Rel(message_service, conversation_service, "updateConversation()")
                Rel(message_service, event_publisher, "publish(message.sent)")
                Rel(event_publisher, nats, "NATS publish")
                Rel(message_service, rate_limiter, "checkLimit()")
                Rel(rate_limiter, redis, "INCR / EXPIRE")
                Rel(ws_gateway, auth_client, "validateToken()")
                Rel(auth_client, auth_service, "HTTP /auth/validate")
            ```
            
            ## Компоненты
            | Компонент | Ответственность |
            |---------|-----------------|
            | `WebSocketGateway` | Подключение клиентов |
            | `MessageController` | HTTP-отправка |
            | `MessageService` | Логика отправки |
            | `MessageRepository` | Хранение сообщений |
            | `ConversationService` | Управление диалогами |
            | `EventPublisher` | Публикация событий |
            | `AuthServiceClient` | Проверка JWT |
            | `RateLimiter` | Ограничение сообщений |
            
            ## Цель
            - Поддержка E2E-шифрования (в будущем)
            - Высокая производительность при нагрузке
            - Готовность к голосовым звонкам
              "
        ---components-user.md---
              "
            # C4 Model: Component Diagram — User Service
            
            ## Описание
            Детализация внутренних компонентов `user-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: User Service
            
                Container_Boundary(user_service, "User Service") {
                    Component(profile_controller, "ProfileController", "HTTP", "GET /users/{id}, PUT /profile")
                    Component(subscription_controller, "SubscriptionController", "HTTP", "Управление подписками")
                    Component(user_service_logic, "UserService", "Business Logic", "Профили, отношения")
                    Component(user_repository, "UserRepository", "PostgreSQL", "CRUD пользователей")
                    Component(event_publisher, "EventPublisher", "NATS", "Публикация user.updated")
                    Component(auth_client, "AuthServiceClient", "HTTP", "Валидация JWT")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(auth_service, "Auth Service", "FastAPI")
                Container(nats, "NATS JetStream", "Event Bus")
                Container(postgres, "PostgreSQL", "БД пользователей")
            
                Rel(gateway, profile_controller, "GET /users/{id}")
                Rel(gateway, subscription_controller, "POST /subscribe")
                Rel(profile_controller, user_service_logic, "updateProfile()")
                Rel(subscription_controller, user_service_logic, "subscribe()")
                Rel(user_service_logic, user_repository, "Сохранение/чтение")
                Rel(user_repository, postgres, "SQL")
                Rel(user_service_logic, event_publisher, "publish(user.updated)")
                Rel(event_publisher, nats, "NATS publish")
                Rel(profile_controller, auth_client, "validateToken()")
                Rel(auth_client, auth_service, "HTTP /auth/validate")
            ```
            
            ## Компоненты
            | Компонент | Ответственность |
            |---------|-----------------|
            | `ProfileController` | Управление профилем |
            | `SubscriptionController` | Подписки между пользователями |
            | `UserService` | Бизнес-логика (друзья, подписки) |
            | `UserRepository` | Работа с БД |
            | `EventPublisher` | Публикация событий |
            | `AuthServiceClient` | Проверка JWT |
            
            ## Цель
            - Поддержка социальных функций (подписки)
            - Интеграция с `auth-service` и `nats`
            - Готовность к мультисайтовости
              "
        ---containers.md---
              "
            # Container Diagram
            
            ## Контейнеры
            
            | Контейнер         | Технология           | Описание                      |
            |-------------------|----------------------|-------------------------------|
            | Web App           | Next.js              | Веб-интерфейс                 |
            | Mobile App        | React Native         | Мобильные клиенты 			   |
            | API Gateway       | Traefik              | Маршрутизация, аутентификация |
            | Auth Service      | FastAPI              | Регистрация, JWT 			   |
            | Blog Service      | NestJS               | CRUD постов, профили		   |
            | Messaging Service | NestJS + WebSocket   | Диалоги, статусы 			   |
            | AI Orchestrator   | FastAPI + LangChain  | Управление ИИ-агентами 	   |
            | Plugin Hub        | FastAPI              | Управление модулями 		   |
            | NATS | JetStream  | Event Bus            |                               |
            | PostgreSQL        | 15                   | Основная БД 				   |
            | Redis             | 7                    | Кэш, сессии, онлайн-статус    |
            | MinIO             | S3-compatible        | Хранение медиа 			   |
            | Grafana           | + OTel               | Мониторинг					   |
            
            ## Взаимодействие
            - Все запросы → API Gateway → нужный сервис
            - Сервисы общаются через NATS
            - Данные хранятся в изолированных БД
              "
        ---context.md---
              "
            # System Context Diagram
            
            ## Описание
            Показывает систему в её окружении: пользователи, внешние сервисы.
            
            ## Участники
            - **Пользователь** — создаёт блог, пишет посты, общается
            - **Мобильное приложение** — клиент для Android/iOS
            - **Сторонний разработчик** — создаёт модули
            - **GitHub / GitLab** — хостинг кода, CI/CD
            - **Cloud Provider (AWS/GCP)** — инфраструктура
            
            ## Система
            - **Quark Platform** — ядро: блог, мессенджер, ИИ, модульность
            
            ## Внешние зависимости
            - **OpenAI / Ollama** — LLM для ИИ-агентов
            - **Cloudflare** — CDN, WAF, DNS
            - **Sentry** — отслеживание ошибок
              "
        ---deployment.md---
              "
            # Deployment Diagram
            
            ## Окружения
            - **Development** — локально, Docker Compose
            - **Staging** — Kubernetes (minikube), production-like
            - **Production** — Kubernetes (EKS/GKE), autoscaling
            
            ## Узлы
            
            ### Клиентская сторона
            - Браузер (Web)
            - Мобильное устройство (React Native)
            
            ### Сеть
            - Cloudflare: TLS, WAF, DNS, CDN
            
            ### Серверная сторона
            ```
            [Ingress (Traefik)]
                   ↓
            [Pod: auth-service] — PostgreSQL
            [Pod: blog-service] — PostgreSQL
            [Pod: messaging-service] — Redis
            [Pod: ai-orchestrator] — Ollama
            [Pod: plugin-hub]
            [Pod: nats]
            [Pod: minio]
            [Pod: grafana + tempo + loki + prometheus]
            ```
            
            ## Хранилище
            - **PostgreSQL**: StatefulSet, PVC
            - **MinIO**: 4 ноды, erasure coding
            - **Backups**: Velero + S3
            
            ## Сеть
            - Внутренняя: Kubernetes Service
            - Внешняя: Ingress → Cloudflare
              "
        ---dfd-context.md---
              "
            # DFD-0: Context Diagram (Level 0)
            
            ## Описание
            Показывает взаимодействие системы **Quark** с внешними сущностями.
            
            ```mermaid
            graph TD
                A[Пользователь] -->|HTTP/HTTPS| B(Quark Platform)
                C[Мобильное приложение] -->|API| B
                D[Сторонний разработчик] -->|Модуль| B
                E[GitHub / GitLab] -->|CI/CD| B
                F[Cloud Provider] -->|Инфраструктура| B
            
                B --> G[Grafana / OTel]
                B --> H[Email-сервис]
                B --> I[CDN / MinIO]
            
                style B fill:#2196F3,stroke:#1976D2,color:white
            ```
            
            ## Участники
            - **Пользователь** — создаёт посты, читает, общается
            - **Мобильное приложение** — клиент для Android/iOS
            - **Сторонний разработчик** — загружает модули
            - **GitHub / GitLab** — доставка кода
            - **Cloud Provider** — хостинг (AWS/GCP)
            - **Grafana / OTel** — сбор метрик
            - **Email-сервис** — уведомления
            - **CDN / MinIO** — хранение медиа
            
            ## Потоки данных
            | От | Кому | Данные | Протокол |
            |----|------|--------|---------|
            | Пользователь | Quark | Логин, пост, сообщение | HTTPS |
            | Quark | Пользователь | Лента, профиль, ответ | HTTPS |
            | GitHub | Quark | Docker-образ | CI/CD |
            | Quark | Grafana | Метрики, трейсы | OTLP |
            | Quark | Email | Уведомления | SMTP |
            | Quark | CDN | Изображения | S3 API |
            
              "
        ---dfd-core-processes.md---
              "
            # DFD-1: Core Processes (Level 1)
            
            ## Описание
            Детализирует внутренние процессы системы при ключевых сценариях.
            
            ```mermaid
            graph TD
                subgraph "Внешние сущности"
                    A[Пользователь]
                    C[Admin Panel]
                    D[AI Ops Agent]
                end
            
                subgraph "Quark Platform"
                    B[API Gateway]
                    B --> E[Auth Service]
                    B --> F[BFF]
                    F --> G[Blog Service]
                    F --> H[Messaging Service]
                    F --> I[AI Orchestrator]
            
                    E --> J[(PostgreSQL - Users)]
                    G --> K[(PostgreSQL - Posts)]
                    G --> L[(MinIO - Media)]
                    I --> M[(Redis - Context)]
                    N[NATS JetStream] --> G
                    N --> O[Search Service]
                    N --> P[Notification Service]
            
                    P --> Q[Email Service]
                    P --> R[WebSocket → Пользователь]
            
                    D -->|PR, рекомендации| B
                    C -->|Управление| F
                end
            
                A -->|1. Логин| B
                B -->|2. JWT| A
                A -->|3. POST /posts| B
                F -->|4. Валидация| G
                G -->|5. Сохранение| K
                G -->|6. media.upload| L
                G -->|7. post.published → NATS| N
                N -->|8. index.post| O
                N -->|9. notification.create| P
                P -->|10. Отправка| Q
                P -->|11. WebSocket| A
            
                style K fill:#FFEB3B,stroke:#FFC107
                style L fill:#FFEB3B,stroke:#FFC107
                style J fill:#FFEB3B,stroke:#FFC107
                style M fill:#FFEB3B,stroke:#FFC107
            ```
            
            ## Ключевой сценарий: Публикация поста
            1. Пользователь отправляет пост
            2. BFF валидирует и передаёт `blog-service`
            3. Блог-сервис:
               - Сохраняет текст в PostgreSQL
               - Загружает изображение в MinIO
               - Генерирует событие `post.published`
            4. Событие рассылается:
               - `search-service` — индексирует
               - `notification-service` — отправляет уведомления
               - `ai-orchestrator` — может сгенерировать рекомендации
            
            ## Потоки данных
            | Процесс | Данные | Направление |
            |--------|--------|------------|
            | Аутентификация | JWT | Пользователь ↔ Auth Service |
            | Публикация поста | PostCreate DTO | BFF → Blog Service |
            | Хранение медиа | Binary data | Blog → MinIO |
            | Событие | post.published | Blog → NATS |
            | Индексация | Post ID + text | NATS → Search Service |
            | Уведомление | notification DTO | NATS → Notification Service |
            | Отправка email | Тема, текст | Notification → Email Service |
            | WebSocket | message.sent | Messaging → Пользователь |
              "
        ---tech-matrix.md---
              "
            # Tech Stack Decision Matrix
            
            ## Версия
            1.0
            
            ## Дата
            2025-04-05
            
            ## Цель
            Обосновать выбор технологий на основе **объективных критериев**, а не моды.  
            Показать, почему Quark использует именно эти инструменты.
            
            ---
            
            ## Критерии оценки
            
            | Критерий | Описание |
            |---------|--------|
            | **Производительность** | Скорость, задержка, пропускная способность |
            | **Безопасность** | Поддержка шифрования, аутентификации, изоляции |
            | **Модульность** | Поддержка автономных, стыкуемых сервисов |
            | **Поддержка ИИ** | Удобство интеграции LLM, LangChain, Ollama |
            | **Лёгкость развёртывания** | Простота запуска на локальной машине и в облаке |
            | **Сообщество и документация** | Активность, примеры, поддержка |
            | **Совместимость с ADR** | Соответствие принятым архитектурным решениям |
            
            > ⚖️ Веса:  
            > - Модульность: 20%  
            > - Безопасность: 20%  
            > - Поддержка ИИ: 15%  
            > - Производительность: 15%  
            > - Лёгкость развёртывания: 15%  
            > - Документация: 10%  
            > - Совместимость с ADR: 5%
            
            ---
            
            ## 1. Backend
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **NestJS (TS)** | 8 | 9 | 9 | 7 | 8 | 9 | 10 | **8.3** |
            | FastAPI (Python) | 9 | 8 | 8 | 10 | 9 | 9 | 10 | **8.7** ✅ |
            | Spring Boot | 9 | 9 | 7 | 6 | 6 | 8 | 6 | 7.4 |
            | Go (Gin) | 10 | 9 | 8 | 5 | 7 | 7 | 7 | 7.7 |
            
            > **Выбор: FastAPI + NestJS**  
            > ✅ **FastAPI** — лучший для `ai-orchestrator`, `auth-service` (много ИИ, Python)  
            > ✅ **NestJS** — для `blog-service`, `messaging-service` (TypeScript, удобно с фронтендом)  
            > 🔗 ADR: `adr-005-jwt-auth.md`, `adr-004-ai-ops-agent.md`
            
            ---
            
            ## 2. Frontend
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **React + Next.js** | 8 | 8 | 9 | 8 | 9 | 10 | 10 | **8.7** ✅ |
            | Vue + Nuxt | 7 | 7 | 8 | 7 | 9 | 9 | 9 | 7.8 |
            | Svelte | 9 | 6 | 7 | 5 | 8 | 7 | 7 | 7.0 |
            | Angular | 6 | 9 | 6 | 5 | 5 | 8 | 6 | 6.2 |
            
            > **Выбор: React + Next.js**  
            > ✅ SSR для SEO (блоги), TypeScript, огромное сообщество  
            > 🔗 ADR: `adr-003-module-docking.md` (поддержка micro-frontend)
            
            ---
            
            ## 3. Event Bus
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **NATS JetStream** | 9 | 8 | 10 | 7 | 10 | 8 | 10 | **8.8** ✅ |
            | Kafka | 10 | 9 | 8 | 8 | 6 | 9 | 8 | 8.2 |
            | RabbitMQ | 7 | 7 | 7 | 6 | 8 | 9 | 7 | 7.1 |
            
            > **Выбор: NATS JetStream**  
            > ✅ Лёгкий, простой, поддерживает durable streams, идеален для MVP  
            > 🔗 ADR: `adr-001-nats-vs-kafka.md`
            
            ---
            
            ## 4. API: REST vs gRPC vs GraphQL
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **REST/JSON** | 6 | 8 | 8 | 7 | 10 | 10 | 9 | **8.0** ✅ (внешний API) |
            | **gRPC** | 10 | 9 | 10 | 9 | 7 | 8 | 10 | **9.0** ✅ (внутренний API) |
            | GraphQL | 7 | 7 | 9 | 8 | 6 | 9 | 8 | 7.5 |
            
            > **Выбор: гибридная стратегия**  
            > ✅ **REST** — для внешнего API (простота, OpenAPI)  
            > ✅ **gRPC** — для внутренних вызовов (скорость, типизация)  
            > 🔗 ADR: `adr-006-grpc.md`
            
            ---
            
            ## 5. Базы данных
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **PostgreSQL** | 8 | 9 | 9 | 8 | 9 | 10 | 10 | **8.8** ✅ |
            | MongoDB | 9 | 7 | 8 | 7 | 10 | 9 | 7 | 7.9 |
            | CockroachDB | 9 | 9 | 10 | 7 | 6 | 8 | 9 | 8.0 |
            | Cassandra | 10 | 8 | 9 | 6 | 5 | 7 | 8 | 7.5 |
            
            > **Выбор: PostgreSQL**  
            > ✅ Поддержка JSONB, полнотекстовый поиск, надёжность, репликация  
            > 🔗 ADR: `adr-002-event-driven.md` (единый источник истины)
            
            ---
            
            ## 6. Хранение медиа
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **MinIO** | 9 | 9 | 10 | 7 | 9 | 9 | 10 | **8.9** ✅ |
            | AWS S3 | 10 | 10 | 9 | 8 | 7 | 10 | 8 | 8.8 |
            | Ceph | 9 | 8 | 8 | 6 | 5 | 7 | 8 | 7.1 |
            
            > **Выбор: MinIO**  
            > ✅ Совместим с S3 API, работает локально, open-source  
            > 🔗 ADR: `adr-003-module-docking.md` (локальное развёртывание)
            
            ---
            
            ## 7. Мониторинг
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **OpenTelemetry + Grafana** | 8 | 9 | 10 | 10 | 8 | 9 | 10 | **9.0** ✅ |
            | Prometheus + ELK | 9 | 8 | 8 | 8 | 7 | 9 | 8 | 7.9 |
            | Datadog (SaaS) | 10 | 10 | 7 | 9 | 5 | 10 | 6 | 7.7 |
            
            > **Выбор: OpenTelemetry + Grafana**  
            > ✅ Open-source, поддержка трейсов, метрик, логов, идеален для AI Ops  
            > 🔗 ADR: `adr-004-ai-ops-agent.md`
            
            ---
            
            ## 8. Модульность и плагины
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **Docker + WASM** | 8 | 10 | 10 | 8 | 8 | 7 | 10 | **8.7** ✅ |
            | Electron | 6 | 6 | 7 | 6 | 7 | 8 | 6 | 6.5 |
            | WebExtensions | 7 | 8 | 8 | 5 | 9 | 9 | 7 | 7.3 |
            
            > **Выбор: Docker + WebAssembly**  
            > ✅ **Docker** — для тяжёлых модулей  
            > ✅ **WASM** — для лёгких, безопасных плагинов  
            > 🔗 ADR: `adr-007-wasm-modules.md`
            
            ---
            
            ## 9. ИИ-фреймворки
            
            | Технология | Производительность | Безопасность | Модульность | Поддержка ИИ | Лёгкость развёртывания | Документация | Совместимость с ADR | Итого |
            |-----------|-------------------|-------------|------------|-------------|------------------------|--------------|---------------------|-------|
            | **Ollama + LangChain** | 9 | 8 | 10 | 10 | 9 | 9 | 10 | **9.2** ✅ |
            | HuggingFace Transformers | 10 | 8 | 8 | 10 | 7 | 10 | 8 | 8.6 |
            | TensorFlow Serving | 8 | 9 | 7 | 9 | 5 | 8 | 7 | 7.3 |
            
            > **Выбор: Ollama + LangChain**  
            > ✅ Локальный запуск LLM, поддержка `phi`, `llama3`, `mistral`  
            > ✅ LangChain — для оркестрации агентов  
            > 🔗 `LLM_choice.md`, `adr-004-ai-ops-agent.md`
            
            ---
            
            ## ✅ Итоговые решения
            
            | Категория | Выбор |
            |---------|-------|
            | **Backend** | FastAPI (Python), NestJS (TypeScript) |
            | **Frontend** | React + Next.js |
            | **Event Bus** | NATS JetStream |
            | **API** | REST (внешний), gRPC (внутренний) |
            | **БД** | PostgreSQL, Redis, MinIO, Elasticsearch |
            | **Мониторинг** | OpenTelemetry + Grafana (Tempo, Loki, Mimir) |
            | **Модульность** | Docker + WebAssembly |
            | **ИИ** | Ollama + LangChain + LlamaIndex |
            | **Infra** | Docker + Kubernetes + Traefik + GitHub Actions |
            
            ---
            
            ## ✅ Статус
            - [x] Сравнение альтернатив
            - [x] Обоснование выбора
            - [x] Связь с ADR
            - [x] Готово к использованию в onboarding и аудите
            
            > ✅ **Документ завершён. Архитектура полностью задокументирована.**
              "
    --backup--
        ---backup-strategy.md---
              "
            # Стратегия резервного копирования
            
            | Данные       | Частота    | Хранилище |
            |--------------|------------|-----------|
            | PostgreSQL   | Каждые 6 ч | S3        |
            | MinIO        | Ежедневно  | S3        |
            | Конфигурации | При деплое | Git       |
              "
        ---recovery-checklist.md---
              "
            # Чек-лист восстановления
            
            1. Восстановить БД
            2. Запустить Vault
            3. Поднять NATS
            4. Проверить health всех сервисов
            5. Уведомить команду
              "
    --c4--
        ---c4-components-blog.md---
              "
            # C4 Model: Component Diagram — Blog Service (Level 3)
            
            ## Описание
            Детализирует внутренние компоненты `blog-service`.
            
            ```mermaid
            C4Component
                title Component Diagram: Blog Service
            
                Container_Boundary(blog_service, "Blog Service") {
                    Component(blog_controller, "BlogController", "HTTP", "Обработка /posts, /blogs")
                    Component(blog_service_logic, "BlogService", "Business Logic", "Создание, публикация, права")
                    Component(blog_repository, "BlogRepository", "PostgreSQL", "CRUD операции с постами")
                    Component(media_client, "MediaServiceClient", "gRPC", "Загрузка изображений")
                    Component(event_publisher, "EventPublisher", "NATS", "Отправка post.published")
                    Component(ai_client, "AIOrchestratorClient", "HTTP", "Запрос генерации/модерации")
                }
            
                Container(gateway, "API Gateway", "Traefik")
                Container(media_service, "Media Service", "FastAPI")
                Container(ai_orchestrator, "AI Orchestrator", "FastAPI")
                Container(event_bus, "Event Bus", "NATS")
                Container(postgres, "PostgreSQL", "БД постов")
            
                Rel(gateway, blog_controller, "HTTP POST /posts")
                Rel(blog_controller, blog_service_logic, "Вызов метода")
                Rel(blog_service_logic, blog_repository, "Сохранение/чтение")
                Rel(blog_repository, postgres, "SQL")
                Rel(blog_service_logic, media_client, "Загрузка медиа")
                Rel(media_client, media_service, "gRPC UploadImage")
                Rel(blog_service_logic, event_publisher, "publish(post.published)")
                Rel(event_publisher, event_bus, "NATS publish")
                Rel(blog_service_logic, ai_client, "moderate(content)")
                Rel(ai_client, ai_orchestrator, "HTTP /ai/moderate")
            ```
            
            ## Компоненты
            | Компонент | Ответственность |
            |---------|-----------------|
            | `BlogController` | HTTP-интерфейс |
            | `BlogService` | Бизнес-логика |
            | `BlogRepository` | Работа с БД |
            | `MediaServiceClient` | gRPC-вызов к `media-service` |
            | `EventPublisher` | Публикация событий |
            | `AIOrchestratorClient` | Взаимодействие с ИИ |
            
            ## Цель
            - Показать внутреннюю структуру одного сервиса
            - Помочь разработчикам понять, где вносить изменения
            - Поддержать стандарты модульности и тестирования
              "
        ---c4-containers.md---
              "
            # C4 Model: Container Diagram (Level 2)
            
            ## Описание
            Показывает **основные контейнеры (сервисы)** внутри системы Quark и их взаимодействие.
            
            ```mermaid
            C4Container
                title Container Diagram for Quark
            
                Person(user, "Пользователь", "Конечный пользователь")
                Person(admin, "Администратор", "Управление системой")
            
                System_Boundary(quark, "Quark Platform") {
                    Container(web_app, "Web App", "Next.js", "Веб-интерфейс")
                    Container(mobile_app, "Mobile App", "React Native", "Мобильные клиенты")
                    Container(gateway, "API Gateway", "Traefik", "Маршрутизация, аутентификация")
                    Container(auth_service, "Auth Service", "FastAPI", "Регистрация, JWT")
                    Container(user_service, "User Service", "NestJS", "Профили, подписки")
                    Container(blog_service, "Blog Service", "NestJS", "CRUD постов, мультисайтовость")
                    Container(messaging_service, "Messaging Service", "NestJS + WebSocket", "Диалоги, статусы")
                    Container(ai_orchestrator, "AI Orchestrator", "FastAPI + LangChain", "Управление ИИ-агентами")
                    Container(plugin_hub, "Plugin Hub", "FastAPI", "Управление сторонними модулями")
                    Container(notification_service, "Notification Service", "FastAPI", "Push, email, in-app")
                    Container(search_service, "Search Service", "FastAPI + Elasticsearch", "Поиск по контенту")
                    Container(monitoring, "OpenTelemetry Collector", "OTel", "Сбор метрик, трейсов, логов")
                    Container(event_bus, "Event Bus", "NATS JetStream", "Асинхронная коммуникация")
            
                    Rel(gateway, auth_service, "HTTP")
                    Rel(gateway, blog_service, "HTTP")
                    Rel(gateway, messaging_service, "WebSocket")
                    Rel(gateway, ai_orchestrator, "HTTP")
                    Rel(auth_service, user_service, "JWT validation")
                    Rel(blog_service, event_bus, "post.published")
                    Rel(messaging_service, event_bus, "message.sent")
                    Rel(ai_orchestrator, event_bus, "ai.response.generated")
                    Rel(event_bus, search_service, "index.update")
                    Rel(event_bus, notification_service, "notification.create")
                    Rel(plugin_hub, event_bus, "module.loaded")
                    Rel(monitoring, event_bus, "telemetry")
                }
            
                Rel(user, web_app, "HTTPS")
                Rel(user, mobile_app, "HTTPS")
                Rel(admin, gateway, "Admin API")
                Rel(web_app, gateway, "API calls")
                Rel(mobile_app, gateway, "API calls")
            ```
            
            ## Контейнеры
            Каждый контейнер — это **автономный сервис** с собственной технологией и ответственностью.
            
            ## Взаимодействие
            - Все запросы идут через **API Gateway**
            - Сервисы общаются через **Event Bus (NATS)**
            - **OpenTelemetry** собирает данные со всех сервисов
            
            ## Цель
            - Показать внутреннюю структуру системы
            - Обозначить границы сервисов
            - Подготовить почву для Component Diagrams
              "
        ---c4-context.md---
              "
            # C4 Model: System Context (Level 1)
            
            ## Описание
            Показывает систему **Quark** в её окружении: пользователи, внешние сервисы, зависимости.
            
            ```mermaid
            C4Context
                title System Context Diagram for Quark
            
                Person(user, "Пользователь", "Читает блоги, пишет посты, общается в мессенджере")
                Person(developer, "Сторонний разработчик", "Создаёт и подключает модули")
                Person(admin, "Администратор", "Управляет системой, модерирует контент")
            
                System_Ext(github, "GitHub / GitLab", "CI/CD, хранение кода")
                System_Ext(cloud, "Cloud Provider (AWS/GCP)", "Инфраструктура, хранение")
                System_Ext(ollama, "Ollama / OpenAI", "LLM для ИИ-агентов")
                System_Ext(cloudflare, "Cloudflare", "CDN, WAF, DNS")
                System_Ext(sentry, "Sentry", "Отслеживание ошибок")
                System_Ext(email, "Email-сервис", "Рассылка уведомлений")
            
                System(quark, "Quark Platform", "Модульная платформа: блоги + мессенджер + ИИ")
            
                Rel(user, quark, "Чтение, публикация, общение")
                Rel(developer, quark, "Загрузка модулей через Plugin Hub")
                Rel(admin, quark, "Управление через Admin Panel")
                Rel(quark, github, "Автоматический деплой")
                Rel(quark, cloud, "Развёртывание в облаке")
                Rel(quark, ollama, "Генерация контента, модерация")
                Rel(quark, cloudflare, "HTTPS, защита от DDoS")
                Rel(quark, sentry, "Отправка ошибок")
                Rel(quark, email, "Отправка уведомлений")
            ```
            
            ## Участники
            - **Пользователь** — основной потребитель платформы
            - **Сторонний разработчик** — создаёт модули
            - **Администратор** — управляет системой
            - **Внешние сервисы** — интеграции
            
            ## Цель
            - Показать границы системы
            - Определить взаимодействие с внешним миром
            - Использовать как основу для более детальных диаграмм
              "
    --capacity-plan--
        ---bottleneck-analysis.md---
              "
            # Bottleneck Analysis
            
            ## NATS при 1M сообщений/день
            - —редний размер сообщени¤: 500 байт
            - ќбъЄм: 500 MB/день
            - ѕри 100 RPS Ч легко справл¤етс¤
            - ѕри 1000 RPS Ч рекомендуетс¤ кластеризаци¤
            
            ## PostgreSQL
            - 10K пользователей > 100K постов
            - »ндекс по `authorId` Ч об¤зателен
            - ќжидаемое врем¤ запроса: < 50 мс
            
            ## AI Orchestrator
            - Llama 3 (7B) > 1 запрос = 2s
            - ѕри 10 параллельных > 20s задержка
            - –ешение: очередь + кэширование
            
              "
    --data--
        ---data-flow.md---
              "
            auth → user → blog → media → ai → notification → user
              "
        ---data-lifecycle.md---
              "
            # Жизненный цикл данных
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Определить политики хранения, обработки и удаления данных в системе Quark, с учётом требований GDPR, ФЗ-152 и внутренних стандартов безопасности.
            
            ---
            
            ## 1. Типы данных и сроки хранения
            
            | Тип данных | Пример | Срок хранения | Действие после истечения |
            |----------|--------|----------------|--------------------------|
            | **Посты** | Текст, заголовок, теги | Неограниченно (пока пользователь не удалит) | Архивация (не в поиске) |
            | **Медиа** | Изображения, видео | 5 лет (или до удаления поста) | Удаление из MinIO |
            | **Логи** | HTTP-запросы, ошибки | 30 дней | Автоматическое удаление |
            | **Трейсы (traces)** | Distributed tracing | 7 дней | Удаление |
            | **Метрики** | Latency, RPS | 90 дней | Агрегация и удаление сырых данных |
            | **Контекст ИИ** | Диалоги, промпты | 1 час | Автоматическая очистка |
            | **Сессии** | JWT, cookies | До истечения токена (15 мин) + refresh (7 дней) | Инвалидация |
            | **Данные модерации** | Флаги, комментарии модератора | 3 года | Архивация |
            | **Данные аналитики** | Просмотры, реакции | 2 года | Агрегация, удаление PII |
            | **Резервные копии** | Velero, S3 | 30 дней | Удаление старых версий |
            
            ---
            
            ## 2. Процесс автоматического удаления
            
            ### 2.1. По расписанию
            - Ежедневно в 02:00 UTC запускается **cron-задача**:
              - Удаляет логи старше 30 дней
              - Очищает трейсы старше 7 дней
              - Архивирует аналитику старше 2 лет
            
            ### 2.2. По запросу пользователя
            1. Пользователь нажимает "Удалить аккаунт" в настройках
            2. Система:
               - Помечает все данные как `pending_deletion`
               - Отправляет уведомление: "Ваши данные будут удалены через 7 дней"
               - Через 7 дней:
                 - Удаляет посты, медиа, сессии
                 - Очищает контекст ИИ
                 - Обнуляет PII в аналитике
            3. Подтверждение отправляется пользователю
            
            > ✅ Соответствует **GDPR (право на забвение)** и **ФЗ-152**
            
            ---
            
            ## 3. Хранение и шифрование
            
            | Данные | Хранение | Шифрование |
            |-------|---------|-----------|
            | Посты | PostgreSQL | TDE (at rest), TLS (in transit) |
            | Медиа | MinIO | SSE-S3 (at rest), TLS |
            | Логи | Loki | TLS (in transit) |
            | Трейсы | Tempo | TLS |
            | Контекст ИИ | Redis | AES-256 (at rest), TLS |
            | Резервные копии | S3 | KMS, TLS |
            
            ---
            
            ## 4. Восстановление данных
            - Только **администратор** может восстановить данные в течение 7 дней после удаления
            - Через CLI:
              ```bash
              quark data:restore --user user-123 --backup backup-2025-04-05
              ```
            - Все действия логируются в `audit-log`
              "
        ---data-model.md---
              "
            # Data Model
            
            ```mermaid
            erDiagram
                USER ||--o{ BLOG : has
                USER ||--o{ POST : writes
                POST ||--o{ COMMENT : has
                POST ||--o{ MEDIA : contains
                USER ||--o{ MESSAGE : sends
            ```
              "
        ---resource-schema.md---
              "
            # Resource Schema: Структура данных
            
            ## Blog Post
            ```json
            {
              "id": "string",
              "title": "string",
              "content": "string",
              "authorId": "string",
              "published": "boolean",
              "createdAt": "datetime",
              "updatedAt": "datetime",
              "tags": ["string"],
              "coverImage": "string (URL)"
            }
            ```
            
            ## User
            ```json
            {
              "id": "string",
              "username": "string",
              "email": "string",
              "displayName": "string",
              "avatar": "string",
              "bio": "string",
              "createdAt": "datetime"
            }
            ```
            
            ## Message
            ```json
            {
              "id": "string",
              "senderId": "string",
              "receiverId": "string",
              "content": "string",
              "timestamp": "datetime",
              "isRead": "boolean"
            }
            ```
            
            > ✅ Все схемы используются в OpenAPI и AsyncAPI
              "
    --examples--
        ---nats-event-publisher.py---
              "
            # examples/nats-event-publisher.py
            import asyncio
            from nats.aio.client import Client as NATS
            
            async def publish_event():
                nc = NATS()
                await nc.connect("nats://localhost:4222")
            
                event = {
                    "id": "post-123",
                    "authorId": "user-456",
                    "title": "Мой первый пост",
                    "timestamp": "2025-04-05T12:00:00Z"
                }
            
                await nc.publish("post.published", json.dumps(event).encode())
                await nc.close()
            
            if __name__ == "__main__":
                asyncio.run(publish_event())
              "
        --module-template--
            ---main.py---
                  "
                from fastapi import FastAPI
                import uvicorn
                
                app = FastAPI()
                
                @app.get("/health")
                def health():
                    return {"status": "ok"}
                
                @app.post("/api/v1/analyze")
                def analyze(content: str):
                    # Ваш код анализа SEO
                    return {"score": 85, "suggestions": ["Добавьте ALT-текст"]}
                
                if __name__ == "__main__":
                    uvicorn.run(app, host="0.0.0.0", port=3010)
                  "
            ---module-manifest.yaml---
                  "
                name: seo-analyzer
                version: 1.0.0
                requires:
                  - event_bus: nats
                  - auth: jwt
                exposes:
                  - events: seo.analysis.completed
                  - api: /api/v1/seo
                health_check: /health
                  "
    --ops--
        ---service-map.md---
              "
            # Service Map: Зависимости сервисов
            
            ## Описание
            Визуализация взаимодействия между сервисами.
            
            ```mermaid
            graph TD
                A[Web App] --> B[API Gateway]
                C[Mobile App] --> B
                D[Admin Panel] --> B
            
                B --> E[Auth Service]
                B --> F[BFF]
                F --> G[Blog Service]
                F --> H[Messaging Service]
                F --> I[AI Orchestrator]
            
                G --> J[NATS]
                H --> J
                I --> J
            
                J --> K[Search Service]
                J --> L[Notification Service]
                J --> M[AI Ops Agent]
            
                L --> N[Email Service]
                L --> O[WebSocket]
            
                style E fill:#FF9800
                style G fill:#3F51B5
                style I fill:#E91E63
                style J fill:#00BCD4
            ```
            
            ## Типы зависимостей
            | Тип | Пример |
            |-----|-------|
            | HTTP | BFF → Blog Service |
            | WebSocket | Messaging → Пользователь |
            | NATS | Blog → Search |
            | gRPC | AI Orchestrator → AI Writer |
              "
        ---slo.md---
              "
            # SLO: Service Level Objectives
            
            ## Описание
            Документ определяет **целевые метрики производительности и доступности** для ключевых сервисов Quark.  
            Основан на модели **RED** (Rate, Error, Duration) и **SLI → SLO → Error Budget**.
            
            ---
            
            ## 1. Общие принципы
            
            - **SLI** (Service Level Indicator) — метрика (например, latency)
            - **SLO** (Service Level Objective) — цель (например, 95% запросов < 500 мс)
            - **Error Budget** — допустимый "дефицит" (например, 0.1% ошибок в месяц)
            - Все SLO мониторятся в **Grafana**
            - При исчерпании бюджета — **заморозка новых фич, только исправления**
            
            ---
            
            ## 2. Ключевые сервисы и их SLO
            
            ### 🛡️ `auth-service`
            | Метрика (SLI) | SLO | Измерение |
            |---------------|-----|-----------|
            | Доступность (Availability) | 99.95% | `up == 1` |
            | Latency (p95) | < 300 мс | `http_request_duration_seconds{quantile="0.95"}` |
            | Ошибки (Error Rate) | < 0.05% | `rate(http_requests_total{status=~"5.."}[5m])` |
            | Rate | до 200 RPS | `rate(http_requests_total[1m])` |
            
            > 💡 Обоснование: авторизация — критична для всей системы.
            
            ---
            
            ### 📝 `blog-service`
            | Метрика (SLI) | SLO | Измерение |
            |---------------|-----|-----------|
            | Доступность | 99.9% | `up == 1` |
            | Latency (чтение, p95) | < 500 мс | `http_request_duration_seconds{handler="getPosts", quantile="0.95"}` |
            | Latency (запись, p95) | < 1.5 с | `http_request_duration_seconds{handler="createPost", quantile="0.95"}` |
            | Ошибки | < 0.1% | `rate(http_requests_total{status=~"5.."}[5m])` |
            | Rate (чтение) | до 150 RPS | `rate(http_requests_total{method="GET"}[1m])` |
            | Rate (запись) | до 30 RPS | `rate(http_requests_total{method="POST"}[1m])` |
            
            > 💡 Обоснование: запись медленнее из-за обработки медиа и событий.
            
            ---
            
            ### 🤖 `ai-orchestrator`
            | Метрика (SLI) | SLO | Измерение |
            |---------------|-----|-----------|
            | Доступность | 99.8% | `up == 1` |
            | Latency (p95) | < 2.0 с | `ai_request_duration_seconds{quantile="0.95"}` |
            | Успешность генерации | > 95% | `rate(ai_requests_total{status="success"}[5m])` |
            | Accuracy (качество) | > 85% | [AI Monitoring Dashboard](./monitoring.md) |
            | Rate | до 50 RPS | `rate(ai_requests_total[1m])` |
            
            > 💡 Обоснование: ИИ может быть медленнее, но должен быть точным и стабильным.
            
            ---
            
            ### 💬 `messaging-service`
            | Метрика (SLI) | SLO | Измерение |
            |---------------|-----|-----------|
            | Доступность | 99.9% | `up == 1` |
            | Latency (отправка, p95) | < 400 мс | `http_request_duration_seconds{handler="sendMessage", quantile="0.95"}` |
            | WebSocket: время подключения | < 1.5 с | `websocket_connect_duration_seconds` |
            | Ошибки | < 0.1% | `rate(http_requests_total{status=~"5.."}[5m])` |
            | Rate | до 100 RPS | `rate(http_requests_total[1m])` |
            
            > 💡 Обоснование: мессенджер требует низкой задержки для UX.
            
            ---
            
            ## 3. Error Budget (бюджет ошибок)
            
            | Сервис | Допустимые ошибки в месяц | Время простоя (в часах/месяц) |
            |-------|----------------------------|-------------------------------|
            | `auth-service` | 0.05% | ~0.36 часов (22 минуты) |
            | `blog-service` | 0.1% | ~0.72 часов (43 минуты) |
            | `ai-orchestrator` | 0.2% | ~1.44 часа |
            | `messaging-service` | 0.1% | ~0.72 часов |
            
            > ⚠️ При исчерпании бюджета:
            > - Запрещаются новые фичи
            > - Только исправления и оптимизации
            > - Команда фокусируется на стабильности
            
            ---
            
            ## 4. Алертинг (Alerting Rules)
            
            | Условие | Приоритет | Действие |
            |--------|----------|---------|
            | `latency > 1s for 2m` | Высокий | Telegram-уведомление |
            | `error_rate > 1% for 5m` | Высокий | Алерт в Grafana + Slack |
            | `availability < 99% for 5m` | Критический | Автоматический перезапуск (K8s) + уведомление |
            | `error_budget_remaining < 20%` | Средний | Уведомление команды |
            | `ai_accuracy < 80%` | Средний | Проверка данных, возможна откатка модели |
            
            > 🔧 Правила будут добавлены в `monitoring/alert-rules.yml`.
            
            ---
            
            ## 5. Мониторинг в Grafana
            
            - **Дашборды**:
              - `SLO Overview` — общий статус всех сервисов
              - `Error Budget Burn Rate` — скорость исчерпания бюджета
              - `Latency by Service` — сравнение p95
            - **Источник данных**: Prometheus + OpenTelemetry
            
            ---
            
            ## 6. Пересмотр SLO
            - Раз в **месяц** — анализ
            - При **изменении нагрузки** — пересчёт
            - При **добавлении нового сервиса** — создание SLO
            
            ---
            
            ## ✅ Статус
            - [x] SLO для `auth-service`
            - [x] SLO для `blog-service`
            - [x] SLO для `ai-orchestrator`
            - [x] SLO для `messaging-service`
            - [x] Error Budget
            - [x] Алертинг
            - [x] Мониторинг
            
            > ✅ **Готово. Можно использовать в CI/CD и для отчётов.**
              "
    --quality--
        ---code-review.md---
              "
            # Code Review Guidelines
            
            ## Цель
            Обеспечить качество, безопасность и единообразие кода.
            
            ## Правила
            
            ### Обязательно проверить:
            - [ ] Соответствие ADR
            - [ ] Наличие тестов (unit, integration)
            - [ ] Покрытие линтером (ESLint, Pylint)
            - [ ] Отсутствие секретов в коде
            - [ ] Наличие OpenAPI / AsyncAPI при изменении API
            - [ ] Обновление документации
            
            ### Стиль кода
            - TypeScript: Airbnb + Prettier
            - Python: Black + isort
            - Именование: camelCase (TS), snake_case (Python)
            
            ### Комментарии
            - Не одобрять, если:
              - Код нечитаем
              - Нет обработки ошибок
              - Есть дублирование
            - Поощрять:
              - Чистые функции
              - Маленькие коммиты
              - Хорошие описания PR
            
            ## Процесс
            1. Создаётся PR
            2. Запускаются CI-тесты
            3. Назначается 1–2 ревьюера
            4. После одобрения — мердж
              "
        ---docs-metrics.md---
              "
            # SLO for Docs
            
            ## Цель
            Измерять и поддерживать качество документации.
            
            ## Метрики
            
            | Метрика | Цель | Измерение |
            |--------|------|----------|
            | Покрытие API | 100% | Проверка наличия `openapi.yaml` для каждого сервиса |
            | Актуальность | Обновление раз в квартал | Git: дата последнего коммита |
            | Читаемость | 80+ по Flesch | Анализ текста |
            | Связность | Все ADR имеют `Связанные документы` | Регулярное сканирование |
            
            ## Алертинг
            - Если `docs-coverage < 100%` > блокировка CI
            - Если `last_update > 90 days` > уведомление в Slack
            
            ## Интеграция с CI/CD
            ```yaml
            - name: Check Docs Coverage
              run: |
                ./scripts/check-docs-coverage.sh
                if [ $? -ne 0 ]; then exit 1; fi
              "
        ---test-plan.md---
              "
            # Test Plan
            
            ## Версия
            1.0
            
            ## Дата
            2025-04-05
            
            ## Статус
            Утверждён
            
            ## 1. Цель
            Обеспечить высокое качество кода и стабильность системы Quark на всех этапах разработки, с помощью комплексного подхода к тестированию.
            
            Цель: **95% покрытие по ключевым сервисам, 0 критических багов в production**.
            
            ---
            
            ## 2. Уровни тестирования
            
            | Уровень | Инструменты | Ответственный | Частота | Охват |
            |--------|------------|--------------|--------|-------|
            | **Unit** | Pytest, Jest, unittest | Разработчик | При каждом коммите | Логика функций, валидация |
            | **Integration** | Supertest, Playwright, HTTPX | Разработчик | При каждом коммите | Взаимодействие сервисов, API |
            | **E2E** | Playwright, Cypress | QA / ИИ | Ежедневно | Пользовательские сценарии |
            | **Load** | k6, Locust | DevOps / ИИ | Перед релизом | Производительность, SLO |
            | **Security** | OWASP ZAP, SonarQube, Trivy | Security Team | Перед релизом | Уязвимости, PII, инъекции |
            | **AI-тесты** | ИИ (Qwen) | AI Ops Agent | При генерации кода | Генерация тест-кейсов, edge cases |
            
            ---
            
            ## 3. Ключевые сценарии тестирования
            
            ### 3.1. Аутентификация и профиль
            - Пользователь регистрируется → получает JWT
            - Вход с неверным паролем → 401
            - Обновление профиля → данные сохраняются
            - Удаление аккаунта → все данные удаляются (GDPR)
            
            ### 3.2. Публикация поста
            - Пользователь создаёт пост → пост появляется в ленте
            - Загрузка изображения → сохраняется в MinIO
            - Событие `post.published` → отправляется в NATS
            - `search-service` индексирует пост
            - `notification-service` отправляет уведомление
            
            ### 3.3. Мессенджер
            - Пользователь A отправляет сообщение пользователю B → B получает его
            - WebSocket соединение устойчиво при 300 VU
            - Статус "онлайн" обновляется
            - История сообщений сохраняется
            
            ### 3.4. ИИ-агенты
            - `ai-ops-agent` обнаруживает высокую задержку → предлагает исправление
            - `ai-moderator` блокирует пост с запрещённым контентом
            - `ai-writer` генерирует пост → человек редактирует → публикует
            
            ### 3.5. Модульность
            - Разработчик загружает `seo-analyzer.wasm` → модуль активируется
            - Модуль подписывается на `post.published` → обрабатывает контент
            - При ошибке — изолируется, не падает вся система
            
            ---
            
            ## 4. Процесс тестирования
            
            ### Этап 1: Локальная разработка
            - Разработчик пишет **unit- и integration-тесты**
            - Запускает `pytest` / `jest` локально
            - Проверяет покрытие: `pytest --cov=src`
            
            ### Этап 2: CI/CD Pipeline
            ```yaml
            # .github/workflows/ci.yml
            - name: Run Unit Tests
              run: pytest tests/unit/
            
            - name: Run Integration Tests
              run: pytest tests/integration/
            
            - name: Run E2E Tests
              run: npx playwright test
            
            - name: Run Load Tests
              run: k6 run load-tests/read-posts.js
            
            - name: Security Scan
              run: |
                docker run --rm -v "$PWD:/app" trivy filesystem /app
                sonar-scanner
            ```
            
            ### Этап 3: Staging
            - Запуск **E2E и нагрузочных тестов** на staging
            - Проверка метрик в **Grafana**
            - Ручное тестирование (если нужно)
            
            ### Этап 4: Production
            - **Canary-деплой** 5% трафика
            - Мониторинг ошибок в **Sentry**
            - Если SLO выполняется → 100% rollout
            
            ---
            
            ## 5. Покрытие кода
            - **Минимум**: 80%
            - **Цель**: 95%
            - Измеряется в **SonarQube** и **Grafana**
            - Отчёт: ежедневный в `#testing` канал
            
            ---
            
            ## 6. Ответственные
            | Роль | Ответственный |
            |------|---------------|
            | **Test Lead** | QA Lead |
            | **Unit/Integration** | Разработчик |
            | **E2E** | QA Engineer |
            | **Load Testing** | DevOps |
            | **Security Testing** | Security Team |
            | **AI Test Generation** | AI Ops Agent (Qwen) |
            
            ---
            
            ## 7. Инструменты
            - **Pytest / Jest** — unit-тесты
            - **Playwright / Cypress** — E2E
            - **k6** — нагрузка
            - **OWASP ZAP** — безопасность
            - **SonarQube** — статический анализ
            - **Sentry** — отслеживание ошибок
            - **Grafana** — визуализация покрытия
              "
        ---testing-strategy.md---
              "
            # Testing Strategy
            
            ## Уровни тестирования
            
            | Уровень | Инструмент | Покрытие |
            |--------|-----------|---------|
            | Unit | Jest, Pytest | Логика функций |
            | Integration | Supertest, Playwright | Взаимодействие сервисов |
            | E2E | Cypress, Playwright | Пользовательские сценарии |
            | Load | k6, Locust | Производительность |
            | Security | OWASP ZAP, SonarQube | Уязвимости |
            
            ## Стратегия
            - **Раннее тестирование**: тесты пишутся вместе с кодом
            - **Автоматизация**: все тесты в CI
            - **Миграции**: тесты для миграций БД
            - **ИИ-тесты**: генерация тест-кейсов ИИ
            
            ## Покрытие
            - Минимум: 80%
            - Идеал: 95%
            - Отчёт: в Grafana / SonarQube
            
            ## Сценарии
            - Пользователь регистрируется → создаёт пост → публикует
            - Модератор помечает контент → админ удаляет
            - ИИ генерирует пост → человек редактирует → публикует
              "
    --security--
        ---disaster-recovery-plan.md---
              "
            # Disaster Recovery Plan
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Обеспечить восстановление системы после катастрофы (поломка ЦОД, потеря данных, сбой сети) в рамках:
            - **RTO (Recovery Time Objective)**: 30 минут
            - **RPO (Recovery Point Objective)**: 5 минут
            
            ## 1. Сценарии катастроф
            
            | Сценарий | Приоритет | Описание |
            |--------|----------|---------|
            | Полная потеря ЦОД | Критический | Физический сбой дата-центра |
            | Потеря БД (PostgreSQL) | Критический | Ошибочное удаление, повреждение |
            | Потеря NATS кластера | Высокий | Сбой event bus |
            | Утечка данных | Критический | Компрометация PII |
            | Атака DDoS на API Gateway | Высокий | Недоступность сервиса |
            
            ## 2. Архитектура отказоустойчивости
            
            ```
            [Основной ЦОД]
              │
              ├── PostgreSQL (Primary) → Replication → [Резервный ЦОД]
              ├── MinIO (erasure coding) → Backup → S3
              ├── NATS JetStream (Clustered)
              └── Velero → Ежедневные бэкапы в S3
            
            [Резервный ЦОД]
              │
              ├── PostgreSQL (Standby) → Hot Standby
              ├── MinIO (Replica)
              └── Автоматический failover (via DNS + Cloudflare)
            ```
            
            ## 3. Процесс восстановления
            
            ### 3.1. Потеря ЦОД
            1. Cloudflare переключает DNS на резервный ЦОД
            2. Восстановить PostgreSQL из hot standby
            3. Запустить MinIO с репликами
            4. Проверить работоспособность NATS
            5. Уведомить пользователей о восстановлении
            
            ### 3.2. Потеря БД
            1. Остановить все сервисы, пишущие в БД
            2. Восстановить из бэкапа с помощью Velero:
               ```bash
               velero restore create --from-backup postgres-backup-2025-04-05
               ```
            3. Проверить целостность данных
            4. Запустить сервисы
            5. Провести post-mortem
            
            ### 3.3. Утечка данных
            1. Изолировать сервис-источник
            2. Отозвать все JWT-токены (через `auth-service` blacklist)
            3. Провести аудит доступа
            4. Уведомить пользователей (в рамках GDPR)
            5. Обновить политики безопасности
            
            ## 4. Инструменты
            - **Velero** — бэкап и восстановление K8s
            - **S3** — хранилище бэкапов
            - **Cloudflare** — DNS failover
            - **Vault** — управление секретами
            - **Prometheus + Grafana** — мониторинг восстановления
            
            ## 5. Проверка DRP
            - Раз в **квартал** — тестовое восстановление
            - После **каждого major release**
            - После **изменения инфраструктуры**
              "
        ---iam.md---
              "
            # IAM: Управление идентификацией и доступом
            
            ## Аутентификация
            - **JWT** (JSON Web Token)
            - Стандартный payload:
              ```json
              {
                "sub": "user-123",
                "roles": ["user", "moderator"],
                "permissions": ["posts:read", "posts:write:own"],
                "exp": 1712349278
              }
              ```
            - Срок действия: 15 минут (access), 7 дней (refresh)
            - Подпись: HS256 с ключом из Vault
            
            ## Авторизация
            - **RBAC (Role-Based Access Control)**
            - Роли:
              - `user`: может писать посты, комментировать
              - `moderator`: может помечать контент, просматривать flagged
              - `admin`: полный доступ к панели
            - Права:
              - `posts:read`, `posts:write:own`, `posts:write:any`, `users:ban`
            
            ## Интеграция
            - Все сервисы проверяют JWT через `auth-service/validate`
            - Права проверяются локально по `permissions` в токене
            
              "
        ---identity-access.md---
              "
            # Identity and Access Management
            
            - JWT для аутентификации
            - RBAC для авторизации
              "
        ---incident-response.md---
              "
            # Incident Response Playbook
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Обеспечить быструю, согласованную реакцию на инциденты безопасности и сбои в работе системы.
            
            ## 1. Роли и ответственность (связано с `raci.md`)
            
            | Роль | Ответственный | Действия |
            |------|---------------|---------|
            | **Incident Commander** | Человек (или Qwen при его недоступности) | Координация, принятие решений |
            | **Communicator** | Qwen | Уведомления в Slack/Telegram, отчётность |
            | **Technician** | DevOps / SRE | Восстановление, анализ, исправление |
            | **Auditor** | Человек | Проверка действий, post-mortem |
            
            ## 2. Процесс реагирования
            
            ### Этап 1: Обнаружение
            - Алерт из **Grafana** (latency, error rate)
            - Уведомление в **Slack/Telegram**
            - Автоматическая фиксация времени инцидента
            
            ### Этап 2: Классификация
            | Уровень | Примеры | Реакция |
            |--------|--------|--------|
            | **Критический** | Падение `auth-service`, утечка данных | Немедленное вмешательство |
            | **Высокий** | Ошибки в `blog-service`, DDoS | В течение 15 мин |
            | **Средний** | Медленная работа ИИ | В течение 1 часа |
            
            ### Этап 3: Изоляция
            - Масштабирование сервиса до 0: `kubectl scale deployment/blog-service --replicas=0`
            - Блокировка IP (если DDoS): `iptables` / Cloudflare
            - Отключение модуля: `plugin-hub disable seo-analyzer`
            
            ### Этап 4: Анализ
            - Просмотр логов: `kubectl logs blog-pod-123`
            - Анализ трейсов: Grafana Tempo
            - Проверка событий: NATS consumer
            - Поиск root cause
            
            ### Этап 5: Исправление
            - Откат: `kubectl rollout undo deployment/blog-service`
            - Патч: CI/CD → новый образ
            - Восстановление из бэкапа (если нужно)
            
            ### Этап 6: Post-mortem
            - Заполнение шаблона:
              ```markdown
              ## Что произошло?
              ## Причина?
              ## Как обнаружено?
              ## Как исправлено?
              ## Как предотвратить?
              ```
            - Публикация в `#incidents` канале
            - Обновление `threat-model-report.md`, `slo.md`
            
            ## 3. Типовые сценарии
            
            ### 3.1. Утечка данных
            - Отозвать токены
            - Провести аудит доступа
            - Уведомить пользователей
            
            ### 3.2. DDoS-атака
            - Включить Cloudflare WAF
            - Rate limiting
            - Блокировка IP-диапазонов
            
            ### 3.3. Сбой ИИ-агента
            - Отключить модуль
            - Переключить на резервный агент
            - Провести анализ контекста
            
            ## 4. Инструменты
            - **Grafana** — мониторинг
            - **Sentry** — ошибки
            - **k9s / kubectl** — управление K8s
            - **Slack / Telegram** — коммуникация
            - **Notion / Confluence** — post-mortem
              "
        ---secure-arch-guidelines.md---
              "
            # Руководство по безопасной архитектуре
            
            ## Версия
            1.0
            
            ## Статус
            Утверждён
            
            ## Цель
            Обеспечить безопасность системы на всех уровнях: от кода до инфраструктуры.
            
            ---
            
            ## 1. Общие принципы
            
            - ✅ Все API — HTTPS (TLS 1.3)
            - ✅ Никаких секретов в коде или конфигах → только **Vault**
            - ✅ Минимальные привилегии (Principle of Least Privilege)
            - ✅ Все события — с цифровой подписью
            - ✅ Аудит всех критичных действий
            - ✅ Rate limiting на всех public endpoint’ах
            
            ---
            
            ## 2. Безопасность по сервисам
            
            ### 2.1. `auth-service`
            - ✅ Использует **strong hashing (bcrypt)** для паролей
            - ✅ JWT с коротким сроком жизни (15 мин)
            - ✅ Refresh token — одноразовый, хранится в БД
            - ✅ Rate limiting: 5 попыток входа / минуту
            - ✅ MFA для администраторов (v2)
            
            ### 2.2. `blog-service`
            - ✅ Санитизация HTML (защита от XSS)
            - ✅ Проверка `user_id` при редактировании поста
            - ✅ CORS: только с `quark.com`, `*.quark.com`
            - ✅ Rate limiting: 100 POST / час на пользователя
            
            ### 2.3. `messaging-service`
            - ✅ WebSocket: аутентификация через JWT в URL
            - ✅ Шифрование сообщений в транзите (WSS)
            - ✅ Очистка контекста после сессии
            - ✅ Rate limiting: 100 сообщений / минуту
            
            ### 2.4. `ai-orchestrator`
            - ✅ Ограничение длины промпта (5000 токенов)
            - ✅ Фильтрация запрещённых тем (NSFW, инструкции по вреду)
            - ✅ Контекст — в зашифрованном Redis
            - ✅ Аудит всех генераций
            
            ### 2.5. `plugin-hub`
            - ✅ Модули проходят ручное одобрение
            - ✅ WASM-модули — в песочнице (wasmedge)
            - ✅ Docker-модули — без привилегий, без доступа к сети
            - ✅ Ограниченные права: только подписка на разрешённые события
            
            ---
            
            ## 3. Защита данных
            
            | Уровень | Технология | Описание |
            |--------|-----------|---------|
            | **In Transit** | TLS 1.3 | Все сервисы, NATS, API Gateway |
            | **At Rest** | TDE, AES-256 | PostgreSQL, Redis, MinIO |
            | **Секреты** | HashiCorp Vault | Централизованное управление |
            | **JWT** | HS256 / RS256 | Подпись и валидация |
            | **NATS** | TLS + Auth | Аутентификация и шифрование |
            
            ---
            
            ## 4. Безопасность модулей
            
            - ✅ Все модули должны иметь `module-manifest.yaml`
            - ✅ Проверка цифровой подписи образа
            - ✅ Статический анализ (Trivy, SonarQube) перед деплоем
            - ✅ Запрещены:
              - Прямые вызовы к `auth-service`
              - Доступ к `vault`
              - Выполнение shell-команд
            
            ---
            
            ## 5. Проверка на уязвимости
            
            | Инструмент | Назначение | Частота |
            |----------|-----------|--------|
            | **Trivy** | Сканирование образов | При каждом CI |
            | **SonarQube** | SAST, качество кода | При каждом PR |
            | **OWASP ZAP** | DAST, инъекции | Перед релизом |
            | **k6 + ZAP** | Автоматизированный тест на проникновение | Еженедельно |
            
            ---
            
            ## 6. Рекомендации по протоколам
            
            ### 6.1. JWT
            - ✅ Использовать `sub`, `roles`, `permissions`
            - ✅ Валидировать `exp`, `iss`, `aud`
            - ✅ Хранить секрет в Vault
            
            ### 6.2. NATS
            - ✅ Включить TLS
            - ✅ Использовать JetStream для durable consumers
            - ✅ Настроить rate limiting на потребителях
            
            ### 6.3. gRPC
            - ✅ Использовать mTLS
            - ✅ Валидировать `.proto` схемы
            - ✅ Ограничивать размер сообщений
            
            ### 6.4. WebAssembly
            - ✅ Запускать в `wasmedge` или `wasmtime`
            - ✅ Ограничивать доступ к сети и файловой системе
            - ✅ Разрешать только `http:outbound`, `events:publish`
              "
        ---threat-model-report.md---
              "
            # Threat Model Report (STRIDE)
            
            ## Версия
            1.0
            
            ## Дата
            2025-04-05
            
            ## Автор
            Quark Security Team (с участием Qwen, Grok)
            
            ## Статус
            Утверждён
            
            ---
            
            ## 1. Введение
            
            ### Цель
            Идентифицировать и оценить угрозы безопасности в архитектуре Quark, основанной на микросервисах, event-driven подходе и ИИ-агентах.
            
            ### Область охвата
            - Все сервисы: `auth`, `blog`, `messaging`, `ai-orchestrator`, `plugin-hub`
            - Взаимодействие через API, NATS, WebSocket
            - Хранение данных: PostgreSQL, Redis, MinIO
            - Участники: пользователи, администраторы, сторонние разработчики
            
            ### Методология
            Используется **STRIDE** — матрица угроз от Microsoft:
            - **S**poofing (подделка)
            - **T**ampering (подделка данных)
            - **R**epudiation (отказ от действий)
            - **I**nformation Disclosure (утечка данных)
            - **D**enial of Service (DoS)
            - **E**levation of Privilege (повышение привилегий)
            
            ---
            
            ## 2. Угрозы и контрмеры
            
            ### S1. Подделка токена (Spoofing: JWT)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Атакующий подделывает JWT, чтобы получить доступ к чужому аккаунту |
            | **Цель** | `auth-service`, `api-gateway` |
            | **Пример атаки** | Получен токен через XSS → изменён `sub` → использован для доступа к профилю |
            | **Критичность** | Высокая |
            | **Контрмеры** | 
            | - Использование **сильного секрета (JWT_SECRET)**, хранящегося в **Vault** |
            | - Подпись токена алгоритмом **HS256** (или RS256 при масштабировании) |
            | - Проверка `exp`, `iss`, `aud` в каждом сервисе |
            | - **Short-lived tokens** (15 мин) + refresh token (7 дней) |
            | - Мониторинг подозрительных входов (IP, геолокация) |
            | **Связанные документы** | `adr-005-jwt-auth.md`, `iam.md` |
            
            ---
            
            ### T1. Подделка события (Tampering: Event)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Атакующий подделывает событие (например, `post.published`) с поддельным `user_id` |
            | **Цель** | `NATS JetStream`, `blog-service` |
            | **Пример атаки** | Отправлено событие `post.published` с `user_id=admin` → попытка модерации от имени админа |
            | **Критичность** | Высокая |
            | **Контрмеры** |
            | - Все события подписываются **цифровой подписью** (HMAC) |
            | - Проверка подписи в `event-validator` сервисе |
            | - Валидация `user_id` через `auth-service` при обработке события |
            | - Аудит всех событий в `audit-log` (PostgreSQL) |
            | **Связанные документы** | `asyncapi-events.yaml`, `secure-arch-guidelines.md` |
            
            ---
            
            ### R1. Отказ от действия (Repudiation)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Пользователь опубликовал нарушающий пост и отрицает это |
            | **Цель** | `blog-service`, `moderation-service` |
            | **Пример атаки** | "Я не писал этот пост, это сделал ИИ!" |
            | **Критичность** | Средняя |
            | **Контрмеры** |
            | - **Аудит всех действий** в `audit-log`:
              ```json
              { "user_id": "u123", "action": "post.create", "timestamp": "2025-04-05T10:00:00Z", "ip": "1.2.3.4" }
              ```
            | - Подпись действий ИИ: `ai_agent: "phi-3-mini", approved_by: "user-123"` |
            | - Логирование WebSocket-сессий (для мессенджера) |
            | **Связанные документы** | `data-lifecycle.md`, `incident-response.md` |
            
            ---
            
            ### I1. Утечка данных (Information Disclosure)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Утечка персональных данных (email, IP, медиа) через API или логи |
            | **Цель** | `user-service`, `media-service`, `logs` |
            | **Пример атаки** | `GET /users` возвращает email всех пользователей |
            | **Критичность** | Высокая |
            | **Контрмеры** |
            | - **Минимизация данных в API**: `/users/me` → только свой профиль |
            | - **Шифрование at rest**: PostgreSQL (TDE), MinIO (SSE-S3) |
            | - **Шифрование in transit**: TLS 1.3 для всех сервисов |
            | - **Структурированные логи**: без PII (персональных данных) |
            | - **WAF (Cloudflare)**: защита от инъекций |
            | **Связанные документы** | `compliance-checklist.md`, `secure-arch-guidelines.md` |
            
            ---
            
            ### D1. Атака типа DoS/DDoS (Denial of Service)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Перегрузка сервисов запросами (например, flood на `/auth/login`) |
            | **Цель** | `api-gateway`, `auth-service`, `nats` |
            | **Пример атаки** | 10000 RPS на `/posts` → падение `blog-service` |
            | **Критичность** | Высокая |
            | **Контрмеры** |
            | - **Rate limiting** в API Gateway: 1000 req/hour на IP |
            | - **WAF (Cloudflare)**: защита от DDoS |
            | - **Bulkhead в NATS**: ограничение потребителей |
            | - **Autoscaling (K8s HPA)**: при росте нагрузки |
            | - **Circuit Breaker** в BFF при недоступности сервиса |
            | **Связанные документы** | `capacity-plan.md`, `deployment-runbook.md` |
            
            ---
            
            ### E1. Повышение привилегий (Elevation of Privilege)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Пользователь получает права модератора или администратора без разрешения |
            | **Цель** | `auth-service`, `admin-panel` |
            | **Пример атаки** | В `JWT` изменён `roles: ["admin"]` |
            | **Критичность** | Критическая |
            | **Контрмеры** |
            | - **RBAC (Role-Based Access Control)** во всех сервисах |
            | - **Проверка ролей** через `auth-service` при каждом запросе |
            | - **Минимальные привилегии**: пользователь не может назначить себе роль |
            | - **Аудит изменений ролей** в `audit-log` |
            | - **MFA для администраторов** (на этапе v2) |
            | **Связанные документы** | `iam.md`, `adr-005-jwt-auth.md` |
            
            ---
            
            ## 3. Угрозы, связанные с ИИ
            
            ### AI-T1. Подмена ИИ-агента
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | Злоумышленник подключает вредоносный модуль, имитирующий `ai-moderator` |
            | **Цель** | `plugin-hub`, `ai-orchestrator` |
            | **Контрмеры** |
            | - **Верификация модулей** перед активацией (человек одобряет)
            | - **Песочница (WASM/Docker)**: изоляция выполнения
            | - **Ограничение прав**: модуль не имеет доступа к `auth-service`
            | - **Мониторинг поведения**: аномалии в генерации контента
            
            ---
            
            ### AI-I1. Утечка контекста ИИ
            
            | Атрибут | Значение |
            |--------|--------|
            | **Описание** | ИИ-агент сохраняет и передаёт конфиденциальные данные из диалогов |
            | **Контрмеры** |
            | - **Очистка контекста** после сессии
            | - **Нет хранения в логах**
            | - **Шифрование контекста** в Redis
            | - **Политика хранения**: 1 час
            
            ---
            
            ## 4. Риски, связанные с модульностью
            
            | Риск | Описание | Контрмера |
            |------|--------|----------|
            | **Небезопасный модуль** | Сторонний модуль содержит уязвимость | Песочница, ручное одобрение |
            | **Несовместимость событий** | Модуль отправляет события в неверном формате | Проверка схемы в `Schema Registry` |
            | **Перегрузка event bus** | Модуль генерирует слишком много событий | Rate limiting на уровне NATS |
            
            ---
            
            ## 5. Инструменты и процессы
            
            | Инструмент | Назначение |
            |----------|-----------|
            | **OWASP ZAP** | Сканирование на уязвимости |
            | **SonarQube** | Статический анализ кода |
            | **Sentry** | Отслеживание ошибок и исключений |
            | **Vault** | Управление секретами |
            | **Grafana + OpenTelemetry** | Мониторинг аномалий |
            | **k6 + OWASP ZAP** | Автоматизированное тестирование на проникновение |
            
            ---
            
            ## 6. Incident Response (связь с `incident-response.md`)
            
            При обнаружении угрозы:
            1. Получен алерт (Grafana/Sentry)
            2. Уведомление команды (Telegram/Slack)
            3. Изоляция сервиса (K8s: scale to 0)
            4. Анализ логов и трейсов
            5. Исправление
            6. Post-mortem и обновление этого документа
            
            ---
            
            ## 7. Пересмотр
            - Раз в **квартал**
            - После **каждого инцидента**
            - При **добавлении нового критичного сервиса**
              "
        ---threat-model.md---
              "
            # Threat Model (STRIDE)
            
            - **S**poofing: JWT подделка → цифровая подпись
            - **T**ampering: изменение события → хеш
            - **R**epudiation: отрицание действия → аудит
            - **I**nformation disclosure: утечка → шифрование
            - **D**enial of service: flood → rate limiting
            - **E**levation of privilege: → RBAC
              "
    --templates--
        ---incident-postmortem-template.md---
              "
            # Post-Mortem Report
            
            ## Инцидент
            - **Название**: 
            - **Дата**: 
            - **Уровень**: Критический / Высокий / Средний
            
            ## Что произошло?
            (Описание, timeline)
            
            ## Причина?
            (Корневая причина: техническая, человеческая, процессная)
            
            ## Как обнаружено?
            (Алерт, пользователь, мониторинг)
            
            ## Как исправлено?
            (Действия, команды, время восстановления)
            
            ## Как предотвратить?
            - [ ] Обновить документацию
            - [ ] Добавить тест
            - [ ] Улучшить мониторинг
            - [ ] Обучить команду
            
            ## Ответственные
            - **Incident Commander**: 
            - **Technician**: 
            - **Auditor**: 
            
            ## Статус
            - [ ] Черновик
            - [ ] Утверждён
            - [ ] Закрыт
            
            
            ---
            
            #### 📁 `docs/examples/`
            > Примеры кода и контрактов
            
            Создай папку `docs/examples/` с файлами:
            
            - `grpc/blog-service.proto`
            - `openapi/example-request-response.json`
            - `module-manifest-full.yaml`
            - `event-example.json`
            
            Пример: `docs/examples/grpc/blog-service.proto`
            ```protobuf
            syntax = "proto3";
            
            package blog;
            
            service BlogService {
              rpc CreatePost(CreatePostRequest) returns (CreatePostResponse);
              rpc GetPost(GetPostRequest) returns (GetPostResponse);
            }
            
            message CreatePostRequest {
              string title = 1;
              string content = 2;
              string author_id = 3;
            }
            
            message CreatePostResponse {
              string post_id = 1;
              string status = 2;
            }
            
            message GetPostRequest {
              string post_id = 1;
            }
            
            message GetPostResponse {
              string title = 1;
              string content = 2;
              string author_id = 3;
              bool published = 4;
            }
            ```
              "
    --testing--
        ---load-test-scenarios.md---
              "
            # Load Test Scenarios
            
            ## 1. Цель
            Проверить производительность системы под нагрузкой, приближенной к продакшену, и убедиться, что SLO выполняются:
            - Latency < 500 мс (p95)
            - Error Rate < 0.1%
            - Доступность > 99.9%
            
            ## 2. Инструмент
            - **k6** — для нагрузочного тестирования
            - **Grafana + Prometheus** — для мониторинга метрик в реальном времени
            - **Docker** — для запуска тестов в изолированной среде
            
            ## 3. Окружение
            - **Staging-кластер**, идентичный production (Kubernetes)
            - **База данных**: PostgreSQL + Redis + MinIO
            - **Event Bus**: NATS JetStream
            - **Масштабирование**: HPA включён
            
            ---
            
            ## 4. Сценарии
            
            ### 4.1. Чтение постов
            
            | Атрибут | Значение |
            |--------|--------|
            | **Цель** | Проверить latency и ошибки при массовом чтении |
            | **Пользователи (VU)** | 1000 |
            | **Длительность** | 10 минут |
            | **Нагрузка** | 70 RPS |
            | **Точка входа** | `GET /api/v1/posts?limit=20` |
            | **SLO** | p95 < 500 мс, error rate < 0.1% |
            
            #### k6-скрипт (`load-tests/read-posts.js`)
            ```javascript
            import http from 'k6/http';
            import { check, sleep } from 'k6';
            
            export const options = {
              vus: 1000,
              duration: '10m',
              thresholds: {
                http_req_duration: ['p(95)<500'],
                http_req_failed: ['rate<0.001'],
              },
            };
            
            export default function () {
              const res = http.get('https://staging.quark.com/api/v1/posts?limit=20');
              check(res, {
                'status was 200': (r) => r.status === 200,
                'response time OK': (r) => r.timings.duration < 500,
              });
              sleep(1);
            }
            ```
            
            ---
            
            ### 4.2. Публикация постов
            
            | Атрибут | Значение |
            |--------|--------|
            | **Цель** | Проверить обработку медиа и событий при массовой публикации |
            | **Пользователи (VU)** | 500 |
            | **Длительность** | 15 минут |
            | **Нагрузка** | 20 RPS |
            | **Точка входа** | `POST /api/v1/posts` (с изображением 1MB) |
            | **SLO** | p95 < 1.5s, error rate < 0.2% |
            
            #### k6-скрипт (`load-tests/publish-posts.js`)
            ```javascript
            import http from 'k6/http';
            import { check, sleep } from 'k6';
            import { randomItem } from 'https://jslib.k6.io/k6-utils/1.4.0/index.js';
            
            // Имитация изображения (base64)
            const image = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=';
            
            export const options = {
              vus: 500,
              duration: '15m',
              thresholds: {
                http_req_duration: ['p(95)<1500'],
                http_req_failed: ['rate<0.002'],
              },
            };
            
            export default function () {
              const payload = JSON.stringify({
                title: `Post by VU ${__VU}`,
                content: 'Тестовый пост для нагрузочного теста',
                status: 'published',
              });
            
              const params = {
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${randomToken()}`,
                },
              };
            
              const res = http.post('https://staging.quark.com/api/v1/posts', payload, params);
              check(res, {
                'status was 201': (r) => r.status === 201,
                'response time OK': (r) => r.timings.duration < 1500,
              });
            
              // Имитация загрузки медиа
              const mediaRes = http.post('https://staging.quark.com/api/v1/media', image, {
                ...params,
                headers: { ...params.headers, 'Content-Type': 'text/plain' },
              });
            
              sleep(2);
            }
            
            function randomToken() {
              return `mock-jwt-token-${__VU}`;
            }
            ```
            
            ---
            
            ### 4.3. Отправка сообщений (WebSocket)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Цель** | Проверить стабильность WebSocket и обработку событий |
            | **Пользователи (VU)** | 300 |
            | **Длительность** | 10 минут |
            | **Нагрузка** | 30 RPS (сообщений) |
            | **Точка входа** | `WS /ws?token=...` |
            | **SLO** | p95 < 400 мс, соединения не рвутся, error rate < 0.1% |
            
            #### k6-скрипт (`load-tests/websocket-messaging.js`)
            ```javascript
            import { check } from 'k6';
            import ws from 'k6/ws';
            
            export const options = {
              vus: 300,
              duration: '10m',
              thresholds: {
                checks: ['rate>0.99'],
                ws_session_duration: ['p(95)<400'],
              },
            };
            
            export default function () {
              const url = `ws://staging.quark.com/ws?token=${randomToken()}`;
              const res = ws.connect(url, {}, function (socket) {
                socket.on('open', function open() {
                  console.log(`VU ${__VU} connected`);
                  socket.setInterval(function timeout() {
                    socket.send(JSON.stringify({
                      type: 'message',
                      content: `Hello from VU ${__VU}`,
                      receiver_id: `user-${__VU + 1}`
                    }));
                  }, 5000);
                });
            
                socket.on('error', function (e) {
                  console.error(`WebSocket error: ${e.error}`);
                });
            
                socket.on('close', function () {
                  console.log('Disconnected');
                });
              });
            
              check(res, { 'status is 101': (r) => r && r.status === 101 });
            }
            ```
            
            ---
            
            ### 4.4. Работа ИИ-агента (генерация контента)
            
            | Атрибут | Значение |
            |--------|--------|
            | **Цель** | Проверить время генерации и стабильность `ai-orchestrator` |
            | **Пользователи (VU)** | 100 |
            | **Длительность** | 5 минут |
            | **Нагрузка** | 10 RPS |
            | **Точка входа** | `POST /ai/generate` |
            | **SLO** | p95 < 2.0s, error rate < 0.5% (из-за LLM) |
            
            #### k6-скрипт (`load-tests/ai-generation.js`)
            ```javascript
            import http from 'k6/http';
            import { check } from 'k6';
            
            export const options = {
              vus: 100,
              duration: '5m',
              thresholds: {
                http_req_duration: ['p(95)<2000'],
                http_req_failed: ['rate<0.005'],
              },
            };
            
            export default function () {
              const payload = JSON.stringify({
                prompt: 'Напиши короткий пост о пользе медитации',
                model: 'phi:mini',
                max_tokens: 200
              });
            
              const params = {
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${randomToken()}`,
                },
              };
            
              const res = http.post('https://staging.quark.com/ai/generate', payload, params);
              check(res, {
                'status was 200': (r) => r.status === 200,
                'response time OK': (r) => r.timings.duration < 2000,
              });
            }
            ```
            
            ---
            
            ## 5. Процесс запуска
            
            1. Запустить staging-окружение
            2. Запустить k6-тест:
               ```bash
               docker run -i loadimpact/k6 run - < load-tests/read-posts.js
               ```
            3. Мониторить в Grafana:
               - CPU, RAM, очередь NATS
               - Latency, errors
            4. Зафиксировать результаты
            5. Если SLO не выполняется — анализировать:
               - Базу данных
               - NATS
               - Кэширование
            6. Внести оптимизации
            
            ---
            
            ## 6. Критерии успеха
            - ? Все сценарии завершены без критических ошибок
            - ? SLO выполнены
            - ? Нет утечек памяти, падений сервисов
            - ? Генерация отчёта в Grafana
            
            ---
            
            ## ? Статус
            - [x] Сценарии определены
            - [x] k6-скрипты созданы
            - [x] SLO привязаны
            - [x] Готово к запуску в CI/CD
            
            > ? **Документ завершён и готов к использованию.**
              "
    --tools--
        ---auto-docs.md---
              "
            # Автоматизированная генерация документации
            
            ## Цель
            Обеспечить **актуальность документации** за счёт интеграции с CI/CD.
            
            ## Инструменты
            
            | Инструмент | Назначение | Интеграция |
            |----------|-----------|-----------|
            | **Swagger (OpenAPI Generator)** | Генерация SDK и документации из кода | FastAPI, NestJS |
            | **Buf** | Валидация и генерация gRPC-контрактов | `*.proto` |
            | **Mermaid Live** | Визуализация диаграмм в GitHub | `.mmd` |
            | **MkDocs + Material** | Автоматическое создание сайта документации | CI/CD |
            | **GitHub Actions** | Автоматический запуск генерации при коммите | `.github/workflows/docs.yml` |
            
            ## Процесс
            1. Разработчик обновляет `openapi.yaml` или `asyncapi-events.yaml`
            2. При PR запускается action:
               ```yaml
               - name: Generate Docs
                 run: |
                   npx @mermaid-js/mermaid-cli -i docs/*.mmd -o docs/diagrams/
                   python -m openapi_spec_validator openapi.yaml
               ```
            3. Обновлённая документация публикуется в `gh-pages`
              "
