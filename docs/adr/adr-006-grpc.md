# ADR-006: Использование gRPC для внутренних вызовов между сервисами

## Состояние
**Принято**

## Контекст
В системе Quark используются два типа взаимодействия:
1. **Асинхронные события** (через NATS) — для большинства сценариев
2. **Синхронные вызовы** — когда нужен немедленный ответ (например, `ai-orchestrator` > `ai-writer`)

Для синхронных вызовов необходимо выбрать **высокопроизводительный, типизированный протокол**, который:
- Быстрее REST
- Поддерживает строгую типизацию
- Работает в условиях высокой нагрузки

## Решение
Использовать **gRPC** для внутренних синхронных вызовов между сервисами.  
**REST остаётся** для внешнего API.

### Примеры использования:
- `ai-orchestrator` > `ai-writer` (генерация текста)
- `blog-service` > `media-service` (проверка статуса загрузки)
- `auth-service` > `user-service` (валидация профиля)

### Технологии:
- **Протокол**: gRPC (HTTP/2 + Protocol Buffers)
- **Генерация кода**: `protoc` + `buf`
- **Сервисы**: `ai-writer`, `ai-moderator`, `media-service`

## Обоснование
| Преимущество | Описание |
|-------------|---------|
| ? **Высокая производительность** | Бинарный формат (Protobuf) уменьшает размер сообщений на 60–80% по сравнению с JSON |
| ? **Строгая типизация** | Ошибки выявляются на этапе компиляции, а не в рантайме |
| ? **Поддержка потоков** | Подходит для ИИ-генерации (server streaming) |
| ? **Генерация SDK** | Автоматическое создание клиентов на Python, TypeScript, Go |
| ? **Встроенные таймауты и retry** | Упрощает обработку сетевых сбоев |

> ?? Подтверждено в `giga-chat_ansver.txt`:  
> _"gRPC — высокоэффективный фреймворк... высокая скорость передачи данных"_

## Альтернативы
| Вариант | Почему не выбран |
|--------|------------------|
| **REST/JSON** | Медленнее, слабая типизация, больше трафика |
| **GraphQL** | Избыточен для внутренних вызовов, сложнее кэшировать |
| **Direct HTTP calls** | Нет контрактов, сложно тестировать |

## Последствия
- ? Сервисы становятся **быстрее и надёжнее**
- ? Требуется **централизованное управление `.proto` файлами** (реестр схем)
- ? Сложнее отлаживать (нужен `grpcurl` или `BloomRPC`)
- ?? Нужно **документировать endpoint’ы в OpenAPI через мост** (например, `grpc-gateway`)

## Связанные документы
- `api-governance.md` — правила API
- `module-manifest.yaml` — указание на `grpc` как на поддерживаемый протокол
- `tech-matrix.md` — сравнение технологий